<?xml version="1.0" encoding="utf-8"?>
<search> 
  
    
    <entry>
      <title>单例模式还可以用枚举来实现吗？</title>
      <link href="/2020/04/19/%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F%EF%BC%88singleton%EF%BC%89/"/>
      <url>/2020/04/19/%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F%EF%BC%88singleton%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h2 id="单例模式（singleton）"><a href="#单例模式（singleton）" class="headerlink" title="单例模式（singleton）"></a>单例模式（singleton）</h2><h2 id="一、什么是单例模式？"><a href="#一、什么是单例模式？" class="headerlink" title="一、什么是单例模式？"></a>一、什么是单例模式？</h2><ul><li>确保内存当中一个类的实例对象只要一个</li></ul><h2 id="二、两种单例模式"><a href="#二、两种单例模式" class="headerlink" title="二、两种单例模式"></a>二、两种单例模式</h2><ul><li><h3 id="饿汉式"><a href="#饿汉式" class="headerlink" title="饿汉式"></a>饿汉式</h3><ul><li><p>步骤</p><ul><li><p>在单例类中定义与自己类型相同的常量，并初始化</p><ul><li>private static final SingletonClass INSTANCE= new SingletonClass();</li></ul></li><li><p>私有化单例类的构造方法</p></li><li>定义一个publish的getInstance方法，返回实例化的常量</li></ul></li><li><p>特点</p><ul><li>在类初始化阶段就完成了单例对象的初始化</li><li>不存在多线程安全问题</li></ul></li></ul></li></ul><a id="more"></a><ul><li><h3 id="懒汉式"><a href="#懒汉式" class="headerlink" title="懒汉式"></a>懒汉式</h3><ul><li><p>特点</p><ul><li>在第一次调用getInstance方法的时候才会初始化单例对象，这也是与‘饿汉式’的区别。</li></ul></li><li><p>实现步骤</p><ul><li><p>单例类中定义一个与自己类型相同的静态变量，不初始化</p><ul><li>private static SIngletonClass INSTANCE;</li></ul></li><li>同样需要私有化单例类的构造方法</li><li>实现getInstance方法</li></ul></li></ul></li><li><h4 id="实现方式一"><a href="#实现方式一" class="headerlink" title="实现方式一"></a>实现方式一</h4></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> SIngletonClass <span class="title">getInstance</span><span class="params">()</span></span>&#123;</div><div class="line"><span class="keyword">if</span>(INSTANCE == <span class="keyword">null</span>)&#123;</div><div class="line"> INSTANCE=<span class="keyword">new</span> SingletonClass();</div><div class="line">&#125;</div><div class="line"><span class="keyword">return</span> INSTANCE;</div><div class="line">&#125;</div></pre></td></tr></table></figure><ul><li><p>存在的问题</p><ul><li>存在多线程安全的问题，可能两个线程分别得到不同的实例</li></ul></li><li><h4 id="实现方式二：synchronized"><a href="#实现方式二：synchronized" class="headerlink" title="实现方式二：synchronized"></a>实现方式二：synchronized</h4><ul><li>在方式一的基础上，给getInstance方法加synchronized关键字</li><li><p>存在的问题</p><ul><li>解决了方式一的多线程安全问题，但是会大大降低运行效率</li></ul></li></ul></li><li><h4 id="实现方式三"><a href="#实现方式三" class="headerlink" title="实现方式三"></a>实现方式三</h4></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> SIngletonClass <span class="title">getInstance</span><span class="params">()</span></span>&#123;</div><div class="line"></div><div class="line"><span class="keyword">if</span>( INSTANCE == <span class="keyword">null</span>)&#123;</div><div class="line"> <span class="keyword">synchronized</span>(SIngletonClass.class)&#123;</div><div class="line">  INSTANCE=<span class="keyword">new</span> SIngletonClass();</div><div class="line">&#125;</div><div class="line"></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">return</span> INSTANCE;</div><div class="line">&#125;</div></pre></td></tr></table></figure><ul><li><p>缺陷：同样有多线程安全问题</p></li><li><h4 id="实现方式四：双重判断加锁"><a href="#实现方式四：双重判断加锁" class="headerlink" title="实现方式四：双重判断加锁"></a>实现方式四：双重判断加锁</h4><ol><li>在方式三的基础上，在synchronized加锁之后，再次对INSTANCE做一次空判断，如果也为空，再初始化单例对象。</li><li>需要使用volatile关键字修饰变量，防止JIT对指令进行重排序<ul><li>private static volatile SingletonClass INSTANCE;</li></ul></li><li>多线程安全的问题得以解决</li></ol></li></ul><ul><li><h4 id="实现方式五：使用内部类的方式实现懒汉式"><a href="#实现方式五：使用内部类的方式实现懒汉式" class="headerlink" title="实现方式五：使用内部类的方式实现懒汉式"></a>实现方式五：使用内部类的方式实现懒汉式</h4><ul><li><p>指导思想：</p><ol><li>JVM“只对每个类加载一次”的原则，保证了多线程安全</li><li>JVM加载外部类时不会加载内部类，这样可以实现懒加载</li></ol></li><li><p>代码实现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SingletonClass</span></span>&#123;</div><div class="line"><span class="function"><span class="keyword">private</span> <span class="title">SingletonClass</span><span class="params">()</span></span>&#123;&#125;;</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">InnerClass</span></span>&#123;</div><div class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> SingletonClass INSTANCE=<span class="keyword">new</span> SingletonClass();</div><div class="line">&#125; </div><div class="line"></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> SingletonClass <span class="title">getInstance</span><span class="params">()</span></span>&#123;</div><div class="line"></div><div class="line"><span class="keyword">return</span> InnerClass.INSTANCE;</div><div class="line">&#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure></li></ul></li><li><h4 id="实现方式六：使用枚举类的方式实现懒汉式"><a href="#实现方式六：使用枚举类的方式实现懒汉式" class="headerlink" title="实现方式六：使用枚举类的方式实现懒汉式"></a>实现方式六：使用枚举类的方式实现懒汉式</h4></li><li><p>好处：</p><ul><li><p>不仅可以解决多线程安全问题，还可以防止反序列化。想其他几种单例的实现方式，都是可以通过反射的方式再次创建实例的。（枚举类没有构造方法）</p></li><li><p>是最简单和安全的实现方式</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">enum</span> SingletonClass&#123;</div><div class="line">INSTANCE;</div><div class="line"></div><div class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method1</span><span class="params">()</span></span>&#123;&#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure></li></ul></li></ul><h2 id="三、总结"><a href="#三、总结" class="headerlink" title="三、总结"></a>三、总结</h2><p>这里列出了7种单例的实现方式，并不是说一定要用哪一种，而是应该结合项目的情况，选择一种合适的实现方式。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 设计模式 </tag>
            
            <tag> DesignPattern </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>代理模式（Proxy）</title>
      <link href="/2020/04/12/%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F%EF%BC%88Proxy%EF%BC%89/"/>
      <url>/2020/04/12/%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F%EF%BC%88Proxy%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h2 id="代理模式（Proxy）"><a href="#代理模式（Proxy）" class="headerlink" title="代理模式（Proxy）"></a>代理模式（Proxy）</h2><h2 id="一、说明"><a href="#一、说明" class="headerlink" title="一、说明"></a>一、说明</h2><ul><li>本文当中出现的代码均为伪代码，可参考文章末尾列出的项目代码地址。</li><li>假设我们的jar包使用maven进行管理。</li></ul><h2 id="二、模式定义"><a href="#二、模式定义" class="headerlink" title="二、模式定义"></a>二、模式定义</h2><ul><li>对访问（或请求）实现拦截和权限的控制，以决定是否需要执行用户的请求。常见的代理体现有Spring AOP、javax.servlet.Filter，与装饰模式很像</li></ul><h2 id="三、静态代理"><a href="#三、静态代理" class="headerlink" title="三、静态代理"></a>三、静态代理</h2><ul><li>使用继承的方式实现代理</li><li>使用组合的方式实现代理</li></ul><a id="more"></a><ul><li><p>缺点</p><ul><li>需要为不同的代理逻辑编写新的代理类</li></ul></li><li><p>角色</p><ul><li>代理</li><li>被代理对象</li></ul></li><li><p>类图</p><ul><li>代理和被代理对象都实现了同一个接口</li></ul></li></ul><h2 id="四、动态代理"><a href="#四、动态代理" class="headerlink" title="四、动态代理"></a>四、动态代理</h2><ul><li><h3 id="4-1JDK动态代理（接口代理）"><a href="#4-1JDK动态代理（接口代理）" class="headerlink" title="4.1JDK动态代理（接口代理）"></a>4.1JDK动态代理（接口代理）</h3></li><li><p>局限</p><ul><li>被代理类必须要实现至少一个接口</li><li>通过反编译查看生成的代理类，其实实现了指定的接口</li></ul></li><li><p>使用步骤</p><p>1.先定义一个接口</p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Moveable</span></span>&#123;</div><div class="line">   <span class="function"><span class="keyword">void</span> <span class="title">move</span><span class="params">()</span></span>;</div><div class="line"> &#125;</div></pre></td></tr></table></figure><p>​        2.定义InvacationHandler</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> MyInvocationhandler implement InvocationHandler&#123;</div><div class="line">Moveable object;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="title">MyInvocationhandler</span><span class="params">(Moveable object)</span></span>&#123;</div><div class="line"> <span class="keyword">this</span>.object=object;</div><div class="line">&#125;</div><div class="line">  </div><div class="line"><span class="meta">@Override</span></div><div class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(Object proxy, Method method , Object[] args)</span></span>&#123;</div><div class="line"></div><div class="line">System.out.println(<span class="string">"执行之前！"</span>);</div><div class="line"><span class="keyword">return</span> method.invoke(object,args);</div><div class="line">&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>​        3.通过JDK API生成接口的代理对象</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Proxy.newProxyInstance(MoveableSub.class.getClassLoader(), <span class="keyword">new</span> Class[]&#123;Moveable.class&#125;,<span class="keyword">new</span> MyInvocationHandler(<span class="keyword">new</span> MoveableSub()))</div></pre></td></tr></table></figure><p>​        4.可以通过设置，将生成的字节码文件（代理类）保存到本地    </p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">System.setProperty(<span class="string">"sun.misc.ProxyGenerator.saveGeneratedFiles"</span>,<span class="string">"true"</span>)</div></pre></td></tr></table></figure><ul><li><p>原理</p><ul><li><p>a&gt; 使用的是一个小而快的字节码工具ASM，生成代理类。因此，Java的动态语言特性其实就是ASM。</p></li><li><p>b&gt; ASM可以直接修改class二进制字节码。</p></li></ul></li></ul><ul><li><h3 id="4-2-Instrument动态代理"><a href="#4-2-Instrument动态代理" class="headerlink" title="4.2 Instrument动态代理"></a>4.2 Instrument动态代理</h3><ul><li>Instrument是一个类似ASM的工具</li><li>原理是在将二进制字节码加载到JVM之前，篡改二进制字节码</li></ul></li><li><h3 id="4-3-CGLIB动态代理（子类代理）"><a href="#4-3-CGLIB动态代理（子类代理）" class="headerlink" title="4.3 CGLIB动态代理（子类代理）"></a>4.3 CGLIB动态代理（子类代理）</h3></li><li><p>局限</p><ul><li>不能对final修饰的类生成代理子类，但是ASM可以突破这种语法上的限制。</li></ul></li><li><p>原理</p><ul><li>底层也是使用ASM工具。</li></ul></li><li><p>使用步骤</p><p>​    1.引入maven依赖</p></li></ul><figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="comment">&lt;!-- https://mvnrepository.com/artifact/cglib/cglib --&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>cglib<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>cglib<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.3.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></div></pre></td></tr></table></figure><p>​        2.编写一个需要被代理的类Example</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Example</span></span>&#123;</div><div class="line"></div><div class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">action</span><span class="params">()</span></span>&#123;</div><div class="line"></div><div class="line">   System.out.println(<span class="string">"我是被代理对象！"</span>);</div><div class="line">&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>​        3.编写代理逻辑（拦截的逻辑）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> MyInterceptor implement MethodInterceptor &#123;</div><div class="line"></div><div class="line"><span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">intercept</span><span class="params">(Object o, Method method, Object[] objects, MethodProxy methodProxy)</span> <span class="keyword">throws</span> Throwable </span>&#123;</div><div class="line">        System.out.println(<span class="string">"这个是产生的代理对象："</span>+o.getClass().getName());    </div><div class="line">    Object invoke =methodProxy.invokeSuper(o,objects);</div><div class="line"></div><div class="line">    <span class="keyword">return</span> invoke;</div><div class="line"></div><div class="line">&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>​        4.Main逻辑</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">Enhancer enhancer=<span class="keyword">new</span> Enhancer();</div><div class="line">enhancer.setSuperClass(Example.class);</div><div class="line">enhancer.setInterceptor(<span class="keyword">new</span> MyInterceptor());</div><div class="line">Example proxy=enhancer.create();</div><div class="line">proxy.action();</div></pre></td></tr></table></figure><h2 id="五、常见案例"><a href="#五、常见案例" class="headerlink" title="五、常见案例"></a>五、常见案例</h2><ul><li>Spring AOP使用了JDK动态代理和CGLIB子类代理</li></ul><h2 id="六、疑问？"><a href="#六、疑问？" class="headerlink" title="六、疑问？"></a>六、疑问？</h2><ul><li><p>JDK动态代理中如果接口当中定义了多个方法，是否生成的代理类中这些方法是否都调用了InvocationHandler::invoke()方法？</p><ul><li>是的，可以通过查看生成代理类的反编译源代码可以知道，代理子类中所有的方法都调用了InvocationHandler::invoke()</li></ul></li></ul><h2 id="七、项目GitHub地址"><a href="#七、项目GitHub地址" class="headerlink" title="七、项目GitHub地址"></a>七、项目GitHub地址</h2><p>​    <a href="https://github.com/tokerr/designpatterns/tree/master/src/main/java/com/nyt/proxy" target="_blank" rel="external">https://github.com/tokerr/designpatterns/tree/master/src/main/java/com/nyt/proxy</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> 设计模式 </tag>
            
            <tag> CGLIB </tag>
            
            <tag> DesignPattern </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Java线程池ThreadPoolExecutor</title>
      <link href="/2020/02/16/Java%E7%BA%BF%E7%A8%8B%E6%B1%A0ThreadPoolExecutor/"/>
      <url>/2020/02/16/Java%E7%BA%BF%E7%A8%8B%E6%B1%A0ThreadPoolExecutor/</url>
      
        <content type="html"><![CDATA[<p>ThreadPoolExecutor是JDK中线程池的重要体现，JDK中的Executors工厂类，提供了不同ThreaPoolExecutor的构建方法，本章的内容主要是对ThreadPoolExecutor的内部结构、运行原理和重点参数做介绍。</p><h1 id="一、继承关系图"><a href="#一、继承关系图" class="headerlink" title="一、继承关系图"></a>一、继承关系图</h1><p><img src="https://raw.githubusercontent.com/tokerr/pic/master/img/3/3.png" alt="类继承关系图"></p><p>#二、内部结构组成</p><ul><li>核心线程数</li><li>最大线程数工作队列</li><li>工作队列</li></ul><a id="more"></a><h1 id="三、构造参数说明"><a href="#三、构造参数说明" class="headerlink" title="三、构造参数说明"></a>三、构造参数说明</h1><ul><li><p>corePoolSize：核心线程的数量</p></li><li><p>maximumPoolSize：最大线程的数量</p></li><li><p>keepAliveTime：普通线程空间之后的存活时间</p></li><li><p>workQueue：类型为BlockingQueue的工作队列，用于保存等待执行任务的任务阻塞队列，有以下几种：</p><pre><code>1） ArrayBlockingQueue：是一个基于数组实现的有界阻塞队列  2）LinkedBlockingQueue：一个基于链表结构的无解阻塞队列  3）SynchronousQueue：一个不存储元素的阻塞队列，每一个插入操作都必须等待另一个线程调用移除操作，否则一直处于阻塞状态</code></pre></li><li><p>RejectedExecutionHandler：饱和策略</p><p>1）CallerRunPolicy：只用调用者所在的线程来处理任务</p><p>2）AbortPolicy（默认）：表示无法处理新任务时抛出异常<br>3）DiscardPolicy：不处理，直接丢弃<br>4）DiscardOldestPolicy：丢弃工作队列里最近的一个任务，并执行当前任务</p></li></ul><h1 id="四、内部运行原理"><a href="#四、内部运行原理" class="headerlink" title="四、内部运行原理"></a>四、内部运行原理</h1><p>​        线程池初始化完毕之后，内部先创建的线程属于核心线程<br>​        假设n为线程池中当前未完成的任务数量；因为有可能会出现类似CacheThreadPool的线程池（它的corePoolSize=0，maximumPoolSize=Integer.MAX_VALUE） ，因此以下情况我们假设：corePoolSize &lt; maximumPoolSize。</p><ol><li>当n &lt; corePoolSize时，对于新提交的任务，将创建新的线程去执行<pre><code>执行这一步需要获取全局锁</code></pre></li><li>当n &gt;= corePoolSize时，对于提交的新任务，将任务保存到工作队列中，当核心线程中有执行完自己的任务，空闲下来后，则从工作队列中取出任务执行</li><li>如果工作队列任务已满，并且maximumPoolSize  &gt;= n &gt;时，对于新提交的任务，将创建新的线程去执行<pre><code>执行这一步需要获取全局锁        </code></pre></li><li>当 n &gt;maximumPoolSize 时，对于新提交的任务，将使用饱和策略进行处理</li></ol><p><img src="https://raw.githubusercontent.com/tokerr/pic/master/img/3/2.png" alt="ThreadPoolExecutor执行图"></p><h1 id="五、向线程池提交任务的方法"><a href="#五、向线程池提交任务的方法" class="headerlink" title="五、向线程池提交任务的方法"></a>五、向线程池提交任务的方法</h1><ol><li>Executor::execute()方法<pre><code>这个方法用于提交不需要返回值的任务，所以无法判断任务是否被线程执行成功，输入的类型是Runnable    </code></pre></li><li>ExecutorService::submit()方法<pre><code>这个方法用于提交需要返回值的任务，方法可以输入Runnable或者Callable，方法返回一个Future类型的对象，通过Future::get()获取返回值</code></pre></li></ol><h1 id="六、关闭线程池"><a href="#六、关闭线程池" class="headerlink" title="六、关闭线程池"></a>六、关闭线程池</h1><p>​        调用shutdown()或shutdownNow()方法来关闭线程池，他们的原理都是遍历线程池中的工作线程，然后逐个调用interrupt()方法中断线程。两者的区别在于，shutdownNow()首先将线程池的状态设置为STOP，然后尝试停止所有的正在执行的或者暂停任务的线程，并返回等待执行任务的列表。shutdown()只是将线程池的状态设置成SHUTDOWN状态，然后中断所有没有正在执行任务的线程。</p>]]></content>
      
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> 线程池 </tag>
            
            <tag> 多线程 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>事务隔离级别</title>
      <link href="/2019/12/01/%E4%BA%8B%E5%8A%A1%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB/"/>
      <url>/2019/12/01/%E4%BA%8B%E5%8A%A1%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB/</url>
      
        <content type="html"><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>​    本文就Mysql数据库的事务进行阐述，包括事务的ACID特性、事务的隔离级别、事务隔离级别解决的问题、事务隔离级别的实现等内容。</p><h2 id="事务的四大特性"><a href="#事务的四大特性" class="headerlink" title="事务的四大特性"></a>事务的四大特性</h2><p>事务的ACID特性，也称为事务的四大特性，分别是：</p><ul><li>原子性（Atomicity）</li><li>一致性（Consistency）</li><li>隔离性（Isolation）</li><li>持久性（Durability）</li></ul><h2 id="事务的隔离级别"><a href="#事务的隔离级别" class="headerlink" title="事务的隔离级别"></a>事务的隔离级别</h2><p>​    事务的隔离性，当数据库中有多个事务执行的时候，就有可能出现“脏读”、“不可重复读”、“幻读”的问题，为了解决这些问题，于是就有了事务的“隔离级别”，事务的隔离级别包括：</p><ul><li>读未提交（Read uncommitted）</li><li>读已提交（Read committed）</li><li>可重复读（Repeatable read）</li><li>串行化（Serializable）</li></ul><a id="more"></a><p>这里一张图可以清楚的看到，不同的隔离级别下可能会出现的问题（X表示不会出现，V表示可能出现）。</p><p><img src="https://raw.githubusercontent.com/tokerr/pic/master/img/2/2.jpg" alt="1.png"></p><p>​    从上往下，事务的隔离级别依次递增，隔离级别越高导致数据库的处理效率越低。所以，需要选择适合自己业务系统的隔离级别，Mysql默认的隔离级别是“可重复读”、Oracle默认的隔离级别是“读已提交”。在将Oracle的数据迁移到Mysql的时候，记得将Mysql的事务隔离级别设置成“读已提交”。Mysql可以通过如下的方式查看和修改事务隔离级别。</p><p>​    使用 show variables 方式查询事务隔离级别：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">show variables like &quot;transaction_isolation&quot;;</div></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/tokerr/pic/master/img/2/1.png" alt="查看事务隔离级别"></p><p>修改事务隔离级别，可以通过修改配置文件，或者在线的方式修改。</p><ol><li><p>修改配置，在系统全局生效：</p><p>在my.cnf中添加或者修改如下配置:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">[mysqld]</div><div class="line">transaction_isolation=REPEATABLE-READ</div></pre></td></tr></table></figure><p>transaction-isolation可选的值有READ-UNCOMMITTED、READ-COMMITTED、REPEATABLE-READ、SERIALIZABLE。</p><p>修改完成需要重启mysql。</p></li><li><p>修改当前会话的隔离级别（在线方式）：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">set session transaction isolation level read committed;</div></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/tokerr/pic/master/img/2/3.png" alt="3"></p></li><li><p>如果希望通过在线方式，全局修改事务隔离级别:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">set global transaction isolation level read uncommitted;</div></pre></td></tr></table></figure><p>分别查看全局和当前会话的事务隔离级别：</p><p><img src="https://raw.githubusercontent.com/tokerr/pic/master/img/2/4.png" alt="4"></p></li></ol><h2 id="事务隔离级别解决的问题"><a href="#事务隔离级别解决的问题" class="headerlink" title="事务隔离级别解决的问题"></a>事务隔离级别解决的问题</h2><p>事务的隔离级别解决的是“脏读（dirty read）”、“不可重复读（non-repeatable read）”、“幻读（phantom read）”的问题。</p><ul><li>脏读：指的是一个事务读取到另一个事务没有提交的数据。</li><li>不可重复读：指的是一个事务访问同一条数据多次，得到的是不同的结果。偏向于指数据的修改。</li><li>幻读：指的是一个事务访问到 同时后者后启动事务插入的数据。偏向于指数据的插入和删除。</li></ul><h2 id="事务的启动方式"><a href="#事务的启动方式" class="headerlink" title="事务的启动方式"></a>事务的启动方式</h2><ol><li><p>显示启动事务语句，begin或者start transaction。配套的提交语句是commit ，回滚语句是rollback;</p></li><li><p>set autocommit=0，这个语句会将线程的自动提交关闭。<strong>为了避免长事务</strong>，应将自动提交开启：set autocommit=1。mysql默认是开启的。</p><p>我们可以通过查询information_schema库的innodb_trx这个表中查询长事务。如下语句是查询持续时间超过60s事务：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">select * from information_schema.innodb_trx where TIME_TO_SEC(timediff(now(),trx_started))&gt;60;</div></pre></td></tr></table></figure></li></ol><h2 id="一致性读视图"><a href="#一致性读视图" class="headerlink" title="一致性读视图"></a>一致性读视图</h2><ol><li><p>使用begin或者start transaction的方式启动事务，一致性读视图是在执行第一个快照读语句的时候创建的。</p></li><li><p>使用如下语句启动事务，一致性读视图是在执行该语句的时候创建的。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">start transaction with consistent snapshot;</div></pre></td></tr></table></figure></li></ol><p>注意，mysql里面有两个视图的概念：</p><ul><li>一个是view。是用查询语句定义的一个虚拟表，创建视图的语法是create view …，查询方式与表一样。</li><li>另一个就是这里提到的，在innodb里面MVCC用到的一致性读视图：consistent read view，用于支持‘读已提交’和‘可重复读’事务隔离级别的实现。</li></ul><h2 id="事务隔离级别的实现"><a href="#事务隔离级别的实现" class="headerlink" title="事务隔离级别的实现"></a>事务隔离级别的实现</h2><p>​    针对读已提交和可重复读两种事务隔离级别，在实现上，数据库会创建一个“一致性读视图”，事务访问的时候以一致性读视图的逻辑结果为准。可重复读级别的一致性读视图，是在事务启动的时候创建，整个时候存在期间都用这个视图；读已提交级别的一致性读视图是在每个SQL语句开始执行的时候创建的。读未提交级别直接返回记录上最新的记录，串行化级别使用加锁的方式避免并行访问，没有“一致性读视图”的概念。</p><p>​    InnoDB中每一行记录都有多个版本（MySQL默认使用InnoDB存储引擎），也就是数据库的多版本并发控制（MVCC）。</p><p>​    MySQL对每一条的记录更新都会记录一条回滚日志（undo log），记录最新的值，同时通过回滚日志可以得到上一个状态的值。</p><p>​    对于不同的‘一致性读视图’，可以通过对当前值，依次执行undo log回滚得到。</p><p>​    回滚日志什么时候删除？mysql会判断，当没有比这个回滚日志更早的一致性读视图时，会将这个回滚日志删除掉。因此，建议不要使用长事务，长事务会导致回滚日志很大，会导致大量占用存储空间。</p>]]></content>
      
      
      
        <tags>
            
            <tag> mysql </tag>
            
            <tag> 事务 </tag>
            
            <tag> 事务隔离级别 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Java内存区域与内存溢出异常</title>
      <link href="/2018/06/02/Java%E5%86%85%E5%AD%98%E5%8C%BA%E5%9F%9F%E4%B8%8E%E5%86%85%E5%AD%98%E6%BA%A2%E5%87%BA%E5%BC%82%E5%B8%B8/"/>
      <url>/2018/06/02/Java%E5%86%85%E5%AD%98%E5%8C%BA%E5%9F%9F%E4%B8%8E%E5%86%85%E5%AD%98%E6%BA%A2%E5%87%BA%E5%BC%82%E5%B8%B8/</url>
      
        <content type="html"><![CDATA[<h1 id="前言："><a href="#前言：" class="headerlink" title="前言："></a>前言：</h1><p>Java与C++之间有一堵由内存动态分配和垃圾收集技术所围成的高墙，墙外面的人想进去，墙里面的人想出来。</p><p>Java程序员把内存控制的权利交给了Java虚拟机（简称：jvm），一旦出现内存泄漏和溢出方面的问题，如果不了解虚拟机是怎样使用内存的，那排插错误将会成为一项异常艰难的工作。</p><p>无论是简单的只是做做增删改查的系统，还是做一个产品也好，很有必要去学习其虚拟机的内存底层结构，以及内存是如何分配和回收的，有助于程序员敲出更高效和稳定的代码。</p><p>通过这篇文章，从概念上介绍JVM内存的各个区域，这些区域的作用、服务对象以及其中可能产生的问题。<br><a id="more"></a></p><h1 id="运行时数据区域"><a href="#运行时数据区域" class="headerlink" title="运行时数据区域"></a>运行时数据区域</h1><p>Java虚拟机在<strong>执行Java程序的过程</strong>中会把它所管理的内存划分为若干个不同的数据区域。这些区域都有各自的用途，以及创建和销毁的时间，有的区域随着虚拟机进程的启动而存在，有些区域则是依赖用户线程的启动和技术而简历和销毁的。Java虚拟所管理的内存区域将会包括一下几个运行时数据区域。</p><h2 id="程序计数器"><a href="#程序计数器" class="headerlink" title="程序计数器"></a>程序计数器</h2><p><strong>介绍:</strong><br>程序计数器(Program counter register)是一块较小的内存控件，它的作用可以看做是当前线程所执行的字节码的行号指示器。</p><p><strong>作用：</strong><br>在虚拟机的概念模型里，字节码的解析器工作时就是通过改变这个计数器的值来选取下一条需要执行的字节码指令，分支、循环、跳转、异常处理、线程回复等基础功能都需要依赖这个计数器来完成。</p><p><strong>服务对象：</strong><br>由于Java虚拟机的多线程是通过线程的轮流切换并分配处理器执行时间的方式来时间的，在任何一个确定的时刻，一个处理器(对于多核处理器来说是一个内核)只会执行一条线程中的指令。因此，为了线程钱换后能回复到正确的执行为孩子，每条线程都需要有一个独立的程序计数器，各个线程之间的计数器互不影响，独立储存，我们称这块内存区域为”线程私有”的内存。</p><p>如果线程正在执行的是一个java方法，这个计数器记录的是正在执行的虚拟机字节码指令的地址；此内存区域是唯一一个在Java虚拟规范中没有规定任何OutOfMemoryError情况的区域。</p><h2 id="Java虚拟机栈"><a href="#Java虚拟机栈" class="headerlink" title="Java虚拟机栈"></a>Java虚拟机栈</h2><p><strong>介绍：</strong><br>与程序计数器一样，Java虚拟机栈(JVM Stacks)也是线程自由的，他的生命周期与线程相同。虚拟机栈描述的是Java方法执行的内存模型：每个方法被执行的时候都会同时创建一个栈帧用于存储局部变量表、操作栈、动态连接、方法出口等信息。每一个方法被调用直至执行完成的过程，就对应这一个栈帧在虚拟机栈中从入栈和出栈的过程。</p><p>局部变量表存放了编译期可知的各种基本数据类型(boolean,byte,char,short,int,float,long,double)、对象引用和returnAddress类型(指向了一条字节码指令的地址)。局部变量表所需要的内存空间在编译期间完成分配，当进入一个方法时，这个方法需要在帧中分配多大的局部变量空间是完全确定的，在方法运行期间不会改变局部变量表的大小。</p><p>在Java虚拟机规范中，对这个区域规定了两种异常状况:<br>如果线程的栈深度大于虚拟机所允许的深的，将抛出StackOverflowError异常；<br>如果虚拟机栈可以动态拓展，当拓展时无法申请到足够的内存时会抛出OutOfMemoryError异常。</p><h2 id="本地方法栈"><a href="#本地方法栈" class="headerlink" title="本地方法栈"></a>本地方法栈</h2><p>本地方法栈(Native Method Stacks)与虚拟机栈所发挥的作用是非常的相似，其区别不过是虚拟机栈为虚拟机执行Java方法(也就是字节码)服务，而本地方法栈则是为虚拟机使用到的Navite方法服务。</p><p>简单地讲，一个Native Method就是一个java调用非java代码的接口，该方法的实现由非java语言实现。</p><h2 id="java堆"><a href="#java堆" class="headerlink" title="java堆"></a>java堆</h2><p>对于大多数的应用，Java堆(Java heap)是java虚拟机所管理的内存中最大的一块。java堆是被所有线程共享的一块内存区域，在虚拟机启动时创建。此内存区域的唯一目的就是存放对象实例，几乎所有的对象实例在这里分配内存。</p><p>java堆是垃圾收集器管理的主要区域，因此很多时候也被称为”GC堆”。</p><h2 id="方法区"><a href="#方法区" class="headerlink" title="方法区"></a>方法区</h2><p>方法区(Method Area)与java堆一样，是各个线程共享的内存区域，它用于存储已被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码等数据。方法区逻辑上属于堆的一部分，但是为了与堆进行区分，通常又叫“非堆”。</p><h3 id="PermGen（永久代）"><a href="#PermGen（永久代）" class="headerlink" title="PermGen（永久代）"></a>PermGen（永久代）</h3><p>绝大部分 Java 程序员应该都见过 “java.lang.OutOfMemoryError: PermGen space “这个异常。这里的 “PermGen space”其实指的就是方法区。不过方法区和“PermGen space”又有着本质的区别。前者是 JVM 的规范，而后者则是 JVM 规范的一种实现，并且只有 HotSpot 才有 “PermGen space”，而对于其他类型的虚拟机，如 JRockit（Oracle）、J9（IBM） 并没有“PermGen space”。由于方法区主要存储类的相关信息，所以对于动态生成类的情况比较容易出现永久代的内存溢出。最典型的场景就是，在 jsp 页面比较多的情况，容易出现永久代内存溢出。</p><p>在 JDK 1.8 中， HotSpot 已经没有 “PermGen space”这个区间了，取而代之是一个叫做 Metaspace（元空间） 的东西。</p>]]></content>
      
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> jvm </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>hadoop2.9.0 编译源码安装</title>
      <link href="/2017/12/17/hadoop2-9-0-%E7%BC%96%E8%AF%91%E6%BA%90%E7%A0%81%E5%AE%89%E8%A3%85/"/>
      <url>/2017/12/17/hadoop2-9-0-%E7%BC%96%E8%AF%91%E6%BA%90%E7%A0%81%E5%AE%89%E8%A3%85/</url>
      
        <content type="html"><![CDATA[<h3 id="1-编译基础环境"><a href="#1-编译基础环境" class="headerlink" title="1.编译基础环境"></a>1.编译基础环境</h3><pre><code>Requirements:* Unix System (我这里使用的是centos 6.8)* JDK 1.8+* Maven 3.0 or later* Findbugs 1.3.9 (if running findbugs)* ProtocolBuffer 2.5.0 （注意版本一定要保持一致，也不能选择更高的版本，否则编译报错）* CMake 2.6 or newer (if compiling native code), must be 3.0 or newer on Mac* Zlib devel (if compiling native code)* openssl devel (if compiling native hadoop-pipes and to get the best HDFS encryption performance)* Linux FUSE (Filesystem in Userspace) version 2.6 or above (if compiling fuse_dfs)* Internet connection for first build (to fetch all Maven and Hadoop dependencies)* python (for releasedocs)* bats (for shell code testing)* Node.js / bower / Ember-cli (for YARN UI v2 building)</code></pre><a id="more"></a><p>备注：由于这里的教程基本都是使用在线安装的方式，包括后面的使用maven对hadoop2.9的源码进行编译，需要下载依赖包，因此请确保服务器连接外网，如果你使用的是vmware虚拟机，可以参考我另一篇博客 <a href="https://tokerr.github.io/2017/12/17/%E8%99%9A%E6%8B%9F%E6%9C%BAhost-only%E4%B8%8B%E9%85%8D%E7%BD%AE%E4%B8%8E%E5%AE%BF%E4%B8%BB%E6%9C%BA%E5%85%B1%E4%BA%AB%E7%BD%91%E7%BB%9C/">vmware虚拟机host-only下配置与宿主机共享网络</a>。</p><h3 id="2-yum-源配置"><a href="#2-yum-源配置" class="headerlink" title="2.yum 源配置"></a>2.yum 源配置</h3><ul><li><p>首先安装wget （已安装则忽略）</p><p>  yum install -y wget</p></li><li><p>将CentOS的yum源更换为国内的阿里云源，我们使用默认的yum源，有时会连接到国外的镜像站导致yum下载比较慢。，所以将默认的yum源替换为阿里云的镜像站。</p></li></ul><p>阿里云Linux安装镜像源地址：<a href="http://mirrors.aliyun.com/" target="_blank" rel="external">http://mirrors.aliyun.com/</a></p><p>备份你的原镜像文件，以免出错后可以恢复。</p><pre><code>mv /etc/yum.repos.d/CentOS-Base.repo /etc/yum.repos.d/CentOS-Base.repo.backup</code></pre><ul><li>下载新的CentOS-Base.repo 到/etc/yum.repos.d/</li></ul><p>CentOS 5 使用下面的链接</p><pre><code>wget -O /etc/yum.repos.d/CentOS-Base.repo http://mirrors.aliyun.com/repo/Centos-5.repo</code></pre><p>CentOS 6 使用下面的链接</p><pre><code>wget -O /etc/yum.repos.d/CentOS-Base.repo http://mirrors.aliyun.com/repo/Centos-6.repo</code></pre><p>CentOS 7 使用下面的链接</p><pre><code>wget -O /etc/yum.repos.d/CentOS-Base.repo http://mirrors.aliyun.com/repo/Centos-7.repo</code></pre><ul><li><p>运行yum makecache生成缓存</p><p>  yum clean all<br><br>  yum makecache</p></li></ul><h3 id="3-yum-安装gcc"><a href="#3-yum-安装gcc" class="headerlink" title="3.yum 安装gcc"></a>3.yum 安装gcc</h3><p>对于配备了yum的Linux发行版而言，安装gcc编译器就变得so easy。我们只需要分别执行如下命令即可：</p><pre><code>yum -y install gcc gcc-c++ kernel-devel</code></pre><h3 id="4-安装CMake"><a href="#4-安装CMake" class="headerlink" title="4.安装CMake"></a>4.安装CMake</h3><pre><code>#wget https://cmake.org/files/v3.3/cmake-3.3.2.tar.gz#tar -zxvf cmake-2.8.10.2.tar.gz#cd cmake-2.8.10.2#./bootstrap#gmake#gmake install</code></pre><h3 id="5-下载Hadoop源码包"><a href="#5-下载Hadoop源码包" class="headerlink" title="5.下载Hadoop源码包"></a>5.下载Hadoop源码包</h3><pre><code>[root@hadoop001 sourcecode]# mkdir -p /opt/sourcecode[root@hadoop001 sourcecode]#wget http://apache.mirrors.tds.net/hadoop/common/stable/hadoop-2.9.0-src.tar.gz[root@hadoop001 sourcecode]#tar -xzvf hadoop-2.9.0-src.tar.gz[root@hadoop001 sourcecode]#cat ./hadoop-2.9.0-src/BUILDING.txt#从BUILDING文件中我们可以看到编译的要求</code></pre><h3 id="6-JDK安装"><a href="#6-JDK安装" class="headerlink" title="6.JDK安装"></a>6.JDK安装</h3><p>这个安装起来相对简单，官网下载个tar包，解压配置环境变量就可以。可以自行百度和google ,可参考我如下系统环境变量配置文件：</p><pre><code># cat /etc/profileJAVA_HOME=/usr/local/work/jdk1.8.0_144MAVEN_HOME=/home/package/apache-maven-3.5.2FINDBUGS_HOME=/home/package/findbugs-3.0.1PROTOBUF_HOME=/usr/local/protobufHADOOP_HOME=/home/hadoop/hadoop-2.9.0CLASSPATH=.:$JAVA_HOME/lib/tools.jarPATH=$JAVA_HOME/bin:$MAVEN_HOME/bin:$FINDBUGS_HOME/bin:$PROTOBUF_HOME/bin:$HADOOP_HOME/bin:$PATHexport JAVA_HOME MAVEN_HOME FINDBUGS_HOME PROTOBUF_HOME HADOOP_HOME CLASSPATH PATH</code></pre><h3 id="7-Maven安装"><a href="#7-Maven安装" class="headerlink" title="7.Maven安装"></a>7.Maven安装</h3><pre><code>#wget 获取tar包#解压#配置环境变量mvn --version #验证</code></pre><h3 id="8-protobuf安装"><a href="#8-protobuf安装" class="headerlink" title="8.protobuf安装"></a>8.protobuf安装</h3><p>protobuf要编译安装，需安装gcc、gcc-c++、 make</p><pre><code>上传 protobuf-2.5.0.tar.gztar -xzvf protobuf-2.5.0.tar.gzcd protobuf-2.5.0yum install -y gcc gcc-c++ make./configure --prefix=/usr/local/protobufmake &amp;&amp; make install#添加protobuf环境变量source /etc/profileprotoc --version</code></pre><h3 id="9-Findbugs安装"><a href="#9-Findbugs安装" class="headerlink" title="9.Findbugs安装"></a>9.Findbugs安装</h3><p>下载tar包，解压，配置环境变量</p><h3 id="10-安装snappy1-1-4-使Hadoop支持snappy压缩10-Snappy压缩库安装"><a href="#10-安装snappy1-1-4-使Hadoop支持snappy压缩10-Snappy压缩库安装" class="headerlink" title="10.安装snappy1.1.4,使Hadoop支持snappy压缩10.Snappy压缩库安装"></a>10.安装snappy1.1.4,使Hadoop支持snappy压缩10.Snappy压缩库安装</h3><pre><code>wget https://github.com/google/snappy/releases/download/1.1.4/snappy-1.1.4.tar.gztar -zxvf snappy-1.1.4.tar.gzcd snappy-1.1.4./configuremake &amp;&amp; make installll -h /usr/local/lib |grep snappy</code></pre><h3 id="11-其他依赖安装"><a href="#11-其他依赖安装" class="headerlink" title="11.其他依赖安装"></a>11.其他依赖安装</h3><pre><code>yum install -y ant openssl openssl-devel svn ncurses-devel zlib-devel libtool svnyum install -y snappy snappy-devel bzip2 bzip2-devel lzo lzo-devel lzop autoconf automake</code></pre><h3 id="12-编译"><a href="#12-编译" class="headerlink" title="12.编译"></a>12.编译</h3><p>进入Hadooop源码目录</p><pre><code>cd hadoop-2.9.0-srcmvn clean package -DskipTests -Pdist,native -Dtar -Dsnappy.lib=/usr/local/lib -Dbundle.snappy</code></pre><h3 id="13-生成tar包"><a href="#13-生成tar包" class="headerlink" title="13.生成tar包"></a>13.生成tar包</h3><p>/home/hadoop/hadoop-2.9.0-src/hadoop-dist/target/hadoop-2.9.0.tar.gz</p><p>以下是我maven编译完成的信息，时间还是比较长的，跟网络也有关系：</p><pre><code>[INFO] ------------------------------------------------------------------------[INFO] BUILD SUCCESS[INFO] ------------------------------------------------------------------------[INFO] Total time: 02:44 h[INFO] Finished at: 2017-12-17T15:26:30+08:00[INFO] Final Memory: 129M/237M[INFO] ------------------------------------------------------------------------</code></pre><p>注意事项：</p><ul><li>由于Maven仓库在墙外，Maven在编译项目时下载包卡住情况，ctrl+c 中断，重新执行编译。</li><li>如果出现提示缺少了某个文件的情况，则要先清理maven(使用命令 mvn clean) 再重新编译。</li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> hadoop </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>虚拟机host-only下配置与宿主机共享网络</title>
      <link href="/2017/12/17/%E8%99%9A%E6%8B%9F%E6%9C%BAhost-only%E4%B8%8B%E9%85%8D%E7%BD%AE%E4%B8%8E%E5%AE%BF%E4%B8%BB%E6%9C%BA%E5%85%B1%E4%BA%AB%E7%BD%91%E7%BB%9C/"/>
      <url>/2017/12/17/%E8%99%9A%E6%8B%9F%E6%9C%BAhost-only%E4%B8%8B%E9%85%8D%E7%BD%AE%E4%B8%8E%E5%AE%BF%E4%B8%BB%E6%9C%BA%E5%85%B1%E4%BA%AB%E7%BD%91%E7%BB%9C/</url>
      
        <content type="html"><![CDATA[<h2 id="准备"><a href="#准备" class="headerlink" title="准备"></a>准备</h2><ul><li>示例环境：</li><li>宿主机：windows7</li><li>虚拟机软件：vmware 12 pro</li><li>虚拟机：centos 6.8</li></ul><p>备注：假设以上的环境已经全部安装完毕</p><h2 id="1-在windows下打开网络适配器设置页面"><a href="#1-在windows下打开网络适配器设置页面" class="headerlink" title="1.在windows下打开网络适配器设置页面"></a>1.在windows下打开网络适配器设置页面</h2><p><img src="https://github.com/tokerr/markdownImage/blob/master/%E8%99%9A%E6%8B%9F%E6%9C%BAhost-only%E4%B8%8B%E9%85%8D%E7%BD%AE%E4%B8%8E%E5%AE%BF%E4%B8%BB%E6%9C%BA%E5%85%B1%E4%BA%AB%E7%BD%91%E7%BB%9C/1.png?raw=true" alt=""><br><a id="more"></a><br>点击进去，看到如下界面：<br><img src="https://github.com/tokerr/markdownImage/blob/master/%E8%99%9A%E6%8B%9F%E6%9C%BAhost-only%E4%B8%8B%E9%85%8D%E7%BD%AE%E4%B8%8E%E5%AE%BF%E4%B8%BB%E6%9C%BA%E5%85%B1%E4%BA%AB%E7%BD%91%E7%BB%9C/2.png?raw=true" alt=""></p><h2 id="2-宿主机所连接的外网通过windows网络共享给VMnet1"><a href="#2-宿主机所连接的外网通过windows网络共享给VMnet1" class="headerlink" title="2.宿主机所连接的外网通过windows网络共享给VMnet1"></a>2.宿主机所连接的外网通过windows网络共享给VMnet1</h2><p>截图可以看到我宿主机所连接的网络是‘无线网络连接’，右键点击其属性，然后切换到共享网卡，勾选“允许其他网络用户通过此计算机的Internet连接来连接”，“请选择一个专用连接”下拉框选择“VMware Network Adapter VMnet1”，点击确定。<br><img src="https://github.com/tokerr/markdownImage/blob/master/%E8%99%9A%E6%8B%9F%E6%9C%BAhost-only%E4%B8%8B%E9%85%8D%E7%BD%AE%E4%B8%8E%E5%AE%BF%E4%B8%BB%E6%9C%BA%E5%85%B1%E4%BA%AB%E7%BD%91%E7%BB%9C/3.png?raw=true" alt=""></p><p>此时会提示VMware Network Adapter VMnet1的IP地址被修改为192.168.137.1，客户机网络配置要用到这个信息（本例为192.168.137.1，<strong>注意，这里经过试验，尽量不要修改这个ip地址，否则会出现配置不成功的现象</strong>）。</p><h2 id="3-准备Linux环境"><a href="#3-准备Linux环境" class="headerlink" title="3.准备Linux环境"></a>3.准备Linux环境</h2><p>3.1点击VMware快捷方式，右键打开文件所在位置 -&gt; 双击vmnetcfg.exe -&gt; VMnet1 host-only -&gt;修改subnet ip 设置网段：192.168.137.0 子网掩码：255.255.255.0 –&gt; 同时关闭DHCP服务-&gt; apply -&gt; ok<br><img src="https://github.com/tokerr/markdownImage/blob/master/%E8%99%9A%E6%8B%9F%E6%9C%BAhost-only%E4%B8%8B%E9%85%8D%E7%BD%AE%E4%B8%8E%E5%AE%BF%E4%B8%BB%E6%9C%BA%E5%85%B1%E4%BA%AB%E7%BD%91%E7%BB%9C/4.png?raw=true" alt=""><br>在虚拟软件上 –My Computer -&gt; 选中虚拟机 -&gt; 右键 -&gt; settings -&gt; network adapter -&gt; host only -&gt; ok </p><p>3.3修改IP/配置DNS</p><p>vim /etc/sysconfig/network-scripts/ifcfg-eth0</p><pre><code>DEVICE=eth0TYPE=EthernetUUID=6169d30a-2243-4a7d-9f03-455d9e0cefa6ONBOOT=noNM_CONTROLLED=yes#BOOTPROTO=dhcpBOOTPROTO=static  ##设置静态IPADDR=192.168.137.101 ##配置ipNETMASK=255.255.255.0 ##配置子网GATEWAY=192.168.137.2 ##配置网关PREFIX=24DNS1=8.8.8.8 ##配置dnsDEFROUTE=yesIPV4_FAILURE_FATAL=yesIPV6INIT=noNAME=&quot;System eth0&quot;HWADDR=00:0C:29:44:CB:D8LAST_CONNECT=1513431454</code></pre><p>保存退出，重启网络服务：</p><pre><code>service network restart</code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> vmware </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>负载均衡session共享解决方法整理</title>
      <link href="/2017/11/20/%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1session%E5%85%B1%E4%BA%AB%E8%A7%A3%E5%86%B3%E6%96%B9%E6%B3%95%E6%95%B4%E7%90%86/"/>
      <url>/2017/11/20/%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1session%E5%85%B1%E4%BA%AB%E8%A7%A3%E5%86%B3%E6%96%B9%E6%B3%95%E6%95%B4%E7%90%86/</url>
      
        <content type="html"><![CDATA[<h2 id="一、背景："><a href="#一、背景：" class="headerlink" title="一、背景："></a>一、背景：</h2><p>最近项目需要上生产，需要部署的节点由原来的单台节点变成了两台节点，使用Nginx实现了负载均衡。因此，上生产之前必须解决登录出现的session共享问题。ps:运维与代码齐下，最后还是选择了一种比较合理并且自己熟悉的方式解决了这个问题！</p><p>项目属于JavaWeb项目，部署在Tomcat环境下。</p><h2 id="二、tomcat集群环境下session共享方法整理"><a href="#二、tomcat集群环境下session共享方法整理" class="headerlink" title="二、tomcat集群环境下session共享方法整理"></a>二、tomcat集群环境下session共享方法整理</h2><p>在集群环境的多个节点保持数据的一致性，session信息这当中是非常重要的一块。要实现这一点，大致有两种思路：</p><p>一是把所有的Session数据放在一台服务器或者数据库当中，集群中所有的节点通过访问这台Session服务器来获取数据；<br><a id="more"></a><br>二是在集群中左右的节点进行Session数据的同步拷贝，所有节点的均保存了所有的Session数据。</p><h3 id="2-1tomcat集群session同步方案有以下几种："><a href="#2-1tomcat集群session同步方案有以下几种：" class="headerlink" title="2.1tomcat集群session同步方案有以下几种："></a>2.1tomcat集群session同步方案有以下几种：</h3><p>1）使用tomcat自带的cluster方式，多个tomcat间自动实时复制session信息，配置起来很简单。使用组播的方式实现session的同步拷贝，但这个方案的效率比较低，在大并发下表现并不好。而且需要另外安装apache的HTTP Server，同样需要一台节点了协调session的拷贝，比较多余，使用的人少，网上的资料比较乱(建议去官网)。<strong>不推荐</strong>。</p><p>2）利用nginx的基于访问ip的hash路由策略，保证访问的ip始终被路由到同一个tomcat上，这个配置更简单。但如果应用是某一个局域网大量用户同时登录，这样负载均衡就没什么作用了。</p><p>3）利用nginx插件实现tomcat集群和session同步，nginx-upstream-jvm-route-0.1.tar.gz，是一个Nginx的扩展模块，用来实现基于Cookie的Session Sticky的功能。</p><p><strong>4）利用memcached实现（MSM工具）。memcached存储session，并把多个tomcat的session集中管理，前端在利用nginx负载均衡和动静态资源分离，在兼顾系统水平扩展的同时又能保证较高的性能。</strong></p><p><strong>5）利用redis实现。使用redis不仅仅可以将缓存的session持久化，还因为它支持的单个对象比较大，而且数据类型丰富，不只是缓存 session，还可以做其他用途，可以一举几得。</strong></p><p><strong>6）利用filter+cookie方式实现。这种方法比较推荐，因为它的服务器使用范围比较多，不仅限于tomcat ，而且实现的原理比较简单容易控制。</strong></p><p>最后三种方法是比较推荐，尝试过第一种方法，但是不推荐，原因已经写明；第四第五种方法，由于公司需要另外申请一台单独的session共享服务器，比较麻烦。最终还是选择了最后一种解决方案，思路简单，实现起来也不难。下面将介绍这种方案。</p><h2 id="三、cookie-filter解决session共享问题"><a href="#三、cookie-filter解决session共享问题" class="headerlink" title="三、cookie+filter解决session共享问题"></a>三、cookie+filter解决session共享问题</h2><p>下面是实现该方案涉及到的三个相关功能，重点在于过滤器的编写。</p><h3 id="3-1-登录成功通知浏览器保存cookie"><a href="#3-1-登录成功通知浏览器保存cookie" class="headerlink" title="3.1 登录成功通知浏览器保存cookie"></a>3.1 登录成功通知浏览器保存cookie</h3><pre><code>public static void setCookie(HttpServletResponse response, HttpServletRequest request, String cookieName,            String cookieValue) {        /**         * a.先判断是否存在cookie ，存在自己设置的cookie则重新设置过期的时间 b.不存在则创建自己cookie 通知客户端保存         * c.需要设置的属性如下： 设置value ,具体值视自己的业务而定，具体设置的之后可以通过构造方法设置name=value         * ，注意使用算法加密 设置编码 设置过期时间 ，设置与session过期时间一致 设置domain 设置path         */        // 声明 cookie        Cookie autoCookie = null;        // 获取所有的cookie        Cookie cookies[] = request.getCookies();        HttpSession session = request.getSession();        // session.getMaxInactiveInterval();//session失效时间，值小于等于0代表永不超时        // 遍历cookie        if (cookies != null &amp;&amp; cookies.length &gt; 0) {            for (Cookie cookie : cookies) {                // 判断是否存在自动登录记录                if (cookieName.equals(cookie.getName())) {                    autoCookie = cookie;// 赋值                    break;                }            }        }        if (autoCookie == null) {            // 不在创建            autoCookie = new Cookie(cookieName, cookieValue);        }        // 设置在执行秒数之后过期；负值意味着cookie不存储，浏览器退出则清除；值为零表示删除cookie        autoCookie.setMaxAge(expiry);// 设置7天之内过期        // 设置编码        // 设置域名domain 默认情况下，Cookie只会返回给发送它们的服务器。        autoCookie.setDomain(request.getServerName());        // 设置path        autoCookie.setPath(request.getContextPath());        // 浏览器的document对象中就看不到cookie        autoCookie.setHttpOnly(true);        response.addCookie(autoCookie);// 添加    }</code></pre><h3 id="3-2-登录退出通知浏览器清除cookie"><a href="#3-2-登录退出通知浏览器清除cookie" class="headerlink" title="3.2 登录退出通知浏览器清除cookie"></a>3.2 登录退出通知浏览器清除cookie</h3><pre><code>public static void cleanCookie(HttpServletRequest request, HttpServletResponse response, String cookieName) {        Cookie cookies[] = request.getCookies();        if (cookies != null &amp;&amp; cookies.length &gt; 0) {            for (Cookie cookie : cookies) {                if (cookieName.equals(cookie.getName())) {                    cookie.setPath(request.getContextPath());// 浏览器回以同Name同Path同Domain覆盖原来的cookie                    cookie.setDomain(request.getServerName());                    cookie.setMaxAge(0);// 通知浏览器删除                    response.addCookie(cookie);                }            }        }    }}</code></pre><h3 id="3-3-编写自动登录过滤器"><a href="#3-3-编写自动登录过滤器" class="headerlink" title="3.3 编写自动登录过滤器"></a>3.3 编写自动登录过滤器</h3><ul><li>1）获取cookie判断用户是否已经登录</li><li>2）未登录则放行</li><li>3）已登录并且本地服务器没有相关session会话信息，则执行自动登录流程</li><li><p>4）自动登录完毕放行</p><pre><code>@Override   public void doFilter(ServletRequest req, ServletResponse resp, FilterChain chain)           throws IOException, ServletException {       /**        * a.到session获取认证信息 ，存在则通过认证，放行并终止程序 不存在执行下一步 b.        * 不存在认证信息，获取cookie，遍历判断是否存在自己设置的cookie，不存在直接放行并终止程序 存在执行下一步        * c.执行自动登录流程，并查询用户必要的信息保存到session当中，执行完毕放行并终止程序        */       HttpServletRequest request = (HttpServletRequest) req;       HttpServletResponse response = (HttpServletResponse) resp;       HttpSession session = request.getSession();       Object token = session.getAttribute(Constant.USER_CONTEXT_LOGGED);       Cookie[] cookies = request.getCookies();       // 用户执行注销操作不进行自动登录       String uri = request.getRequestURI();       String logout = request.getParameter(&quot;logout&quot;);       if (uri.contains(&quot;/projectContextPath/index.html&quot;) &amp;&amp; logout != null &amp;&amp; &quot;true&quot;.equals(logout)) {           StringBuffer url = request.getRequestURL();           response.sendRedirect(url.toString());           return;       }       if (cookies != null &amp;&amp; cookies.length &gt; 0) {// 在session中没有获取到用户信息           Cookie autoCookie = null;// 已登录的cookie           for (Cookie cookie : cookies) {               // 未在本服务器登录，并且在客户端保存有响应的cookie，才会执行自动登录               if (Constant.COOKIE_NAME.equals(cookie.getName()) &amp;&amp; token == null) {// cookie存在                   autoCookie = cookie;               }           }           if (autoCookie != null ) {// 存在cookie                // 开始自动登录，视具体业务根据cookie中的信息查询用户的信息并保存到session中完成自动登录                                                                       startAutoLogin(request, response, autoCookie);           }       }       chain.doFilter(request, response);// 放行   }</code></pre></li></ul><p><em>另外， 安全性问题考虑，由于使用的是cookie保存了用户的信息，容易被黑客拦截篡改。通常cookie中会保存用户名、密码等敏感经过加密，很难反向破解，但也不是绝对的安全，黑客可以通过木马病毒盗取用户浏览器的cookie，直接骗取网站的信任。 最好是使用https。</em></p>]]></content>
      
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> session </tag>
            
            <tag> cookie </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>sqoop学习笔记</title>
      <link href="/2017/10/25/sqoop%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
      <url>/2017/10/25/sqoop%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<p><strong>说明：这里以hadoop2和mysql为例。</strong></p><h2 id="1-上传sqoop到Hadoop集群任意一个节点"><a href="#1-上传sqoop到Hadoop集群任意一个节点" class="headerlink" title="1.上传sqoop到Hadoop集群任意一个节点"></a>1.上传sqoop到Hadoop集群任意一个节点</h2><h2 id="2-安装和配置"><a href="#2-安装和配置" class="headerlink" title="2.安装和配置"></a>2.安装和配置</h2><h3 id="2-1-配置sqoop-env-sh文件"><a href="#2-1-配置sqoop-env-sh文件" class="headerlink" title="2.1 配置sqoop-env.sh文件"></a>2.1 配置sqoop-env.sh文件</h3><p>在sqoop中conf目录下新复制一个sqoop-env.sh文件：<br><br>[root@centos2 conf]# cp sqoop-env-template.sh sqoop-env.sh<br><br>修改配置sqoop-env.sh文件：<br><a id="more"></a><br>    export HADOOP_COMMON_HOME=/home/hadoop/hadoop/hadoop-2.3.0</p><pre><code>#Set path to where hadoop-*-core.jar is availableexport HADOOP_MAPRED_HOME=/home/hadoop/hadoop/hadoop-2.3.0#set the path to where bin/hbase is available#export HBASE_HOME=#Set the path to where bin/hive is available#export HIVE_HOME=#Set the path for where zookeper config dir is#export ZOOCFGDIR=</code></pre><p> 不配置该项会出现Please set $HADOOP_COMMON_HOME to the root的错误提示。</p><h3 id="2-2-添加数据库驱动"><a href="#2-2-添加数据库驱动" class="headerlink" title="2.2 添加数据库驱动"></a>2.2 添加数据库驱动</h3><p>将数据库连接驱动拷贝到$SQOOP_HOME/lib里。注意，这里使用的是Mysql驱动版本不能过低，尽量使用最新的版本，否则可能会出现一下错误：</p><pre><code>ERROR manager.SqlManager: Error reading from database: java.sql.SQLException: Streaming result set</code></pre><h2 id="3-配置mysql远程登录"><a href="#3-配置mysql远程登录" class="headerlink" title="3.配置mysql远程登录"></a>3.配置mysql远程登录</h2><h3 id="3-1-改表："><a href="#3-1-改表：" class="headerlink" title="3.1 改表："></a>3.1 改表：</h3><p>只要在localhost的那台电脑，登入mysql后，更改 “mysql” 数据库里的 “user” 表里的 “host” 项，从”localhost”改称”%”</p><p>登录数据库：mysql -u root -pvmware</p><p>mysql&gt;use mysql;</p><p>mysql&gt;update user set host = ‘%’ where user = ‘root’;</p><p>mysql&gt;select host, user from user;</p><p>mysql&gt;FLUSH RIVILEGES </p><h3 id="3-2-授权："><a href="#3-2-授权：" class="headerlink" title="3.2 授权："></a>3.2 授权：</h3><p>(1)例如，你想myuser使用mypassword从任何主机连接到mysql服务器的话。</p><p>第一步：root用户登录；mysql&gt;mysql -u root -p rootpassword;</p><p>第二步：赋予权限；mysql&gt;GRANT ALL PRIVILEGES ON <em>.</em> TO ‘myuser’@’%’ IDENTIFIED BY ‘mypassword’ WITH GRANT OPTION;</p><p>第三步：mysql&gt;FLUSH   PRIVILEGES;</p><p>(2)如果你想允许用户myuser从ip为192.168.1.3的主机连接到mysql服务器，并使用mypassword作为密码</p><p> mysql&gt;GRANT ALL PRIVILEGES ON <em>.</em> TO ‘myuser’@’192.168.1.3’ IDENTIFIED BY ‘mypassword’ WITH GRANT OPTION;</p><p> mysql&gt;FLUSH   PRIVILEGES;</p><p>(3)如果你想允许用户myuser从ip为192.168.1.3的主机连接到mysql服务器的dk数据库，并使用mypassword作为密码</p><p> mysql&gt;GRANT ALL PRIVILEGES ON dk.* TO ‘myuser’@’192.168.1.3’ IDENTIFIED BY ‘mypassword’ WITH GRANT OPTION;</p><p> mysql&gt;FLUSH   PRIVILEGES;</p><p>说明：这里我使用了第（1）种方法。没有允许mysql远程登录，在使用sqoop导入数据的时候，会出现以下错误：</p><pre><code>message from server: &quot;Host is not allowed to connect to this MySQL server</code></pre><h2 id="4-使用-amp-练习"><a href="#4-使用-amp-练习" class="headerlink" title="4.使用&amp;练习"></a>4.使用&amp;练习</h2><p><strong>第一类：数据库中的数据导入到HDFS上</strong></p><pre><code>sqoop import --connect jdbc:mysql://192.168.1.10:3306/nongyt --username root --password 123  --table trade_detail --columns &apos;id, account, income, expenses&apos;</code></pre><p>指定输出路径、指定数据分隔符</p><pre><code>sqoop import --connect jdbc:mysql://192.168.1.10:3306/nongyt --username root --password 123  --table trade_detail --target-dir &apos;/sqoop/td&apos; --fields-terminated-by &apos;\t&apos;</code></pre><p>指定Map数量 -m</p><pre><code>sqoop import --connect jdbc:mysql://192.168.1.10:3306/nongyt --username root --password 123  --table trade_detail --target-dir &apos;/sqoop/td1&apos; --fields-terminated-by &apos;\t&apos; -m 2</code></pre><p>增加where条件, 注意：条件必须用引号引起来</p><pre><code>sqoop import --connect jdbc:mysql://192.168.1.10:3306/nongyt --username root --password 123  --table trade_detail --where &apos;id&gt;3&apos; --target-dir &apos;/sqoop/td2&apos;</code></pre><p>增加query语句(使用 \ 将语句换行)</p><pre><code>sqoop import --connect jdbc:mysql://192.168.1.10:3306/nongyt --username root --password 123 \--query &apos;SELECT * FROM trade_detail where id &gt; 2 AND $CONDITIONS&apos; --split-by trade_detail.id --target-dir &apos;/sqoop/td3&apos;</code></pre><p><strong><em>注意：</em></strong></p><ul><li><p><em>如果使用–query这个命令的时候，需要注意的是where后面的参数，AND $CONDITIONS这个参数必须加上</em></p></li><li><p><em>而且存在单引号与双引号的区别，如果–query后面使用的是双引号，那么需要在$CONDITIONS前加上\即\$CONDITIONS</em></p></li><li><p><em>如果设置map数量为1个时即-m 1，不用加上–split-by ${tablename.column}，否则需要加上</em></p></li></ul><p><strong>第二类：将HDFS上的数据导出到数据库中(不要忘记指定分隔符)</strong></p><pre><code>sqoop export --connect jdbc:mysql://192.168.8.120:3306/nongyt --username root --password 123 --export-dir &apos;/td3&apos; --table td_bak -m 1 --fields-terminated-by &apos;,&apos;</code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> hadoop </tag>
            
            <tag> sqoop </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>hadoop+zookeeper集群搭建</title>
      <link href="/2017/10/24/hadoop-zookeeper%E9%9B%86%E7%BE%A4%E6%90%AD%E5%BB%BA/"/>
      <url>/2017/10/24/hadoop-zookeeper%E9%9B%86%E7%BE%A4%E6%90%AD%E5%BB%BA/</url>
      
        <content type="html"><![CDATA[<h2 id="前期准备"><a href="#前期准备" class="headerlink" title="前期准备:"></a>前期准备:</h2><p>hadoop2.0已经发布了稳定版本了，增加了很多特性，比如HDFS HA、YARN等。最新的hadoop-2.4.1又增加了YARN HA</p><p>1.修改Linux主机名<br><br>2.修改IP<br><br>3.修改主机名和IP的映射关系<br><a id="more"></a><br>    注意：<br>    如果你们公司是租用的服务器或是使用的云主机（如华为用主机、阿里云主机等）<br>    /etc/hosts里面要配置的是内网IP地址和主机名的映射关系<br>4.关闭防火墙<br><br>5.ssh免登陆 <br><br>6.安装JDK，配置环境变量等<br></p><h2 id="集群规划："><a href="#集群规划：" class="headerlink" title="集群规划："></a>集群规划：</h2><pre><code>主机名        IP                安装的软件                    运行的进程nongyt01    192.168.1.201    jdk、hadoop                    NameNode、DFSZKFailoverController(zkfc)nongyt02    192.168.1.202    jdk、hadoop                    NameNode、DFSZKFailoverController(zkfc)nongyt03    192.168.1.203    jdk、hadoop                    ResourceManagernongyt04    192.168.1.204    jdk、hadoop                    ResourceManagernongyt05    192.168.1.205    jdk、hadoop、zookeeper        DataNode、NodeManager、JournalNode、QuorumPeerMainnongyt06    192.168.1.206    jdk、hadoop、zookeeper        DataNode、NodeManager、JournalNode、QuorumPeerMainnongyt07    192.168.1.207    jdk、hadoop、zookeeper        DataNode、NodeManager、JournalNode、QuorumPeerMain</code></pre><h3 id="说明："><a href="#说明：" class="headerlink" title="说明："></a>说明：</h3><p>1.在hadoop2.0中通常由两个NameNode组成，一个处于active状态，另一个处于standby状态。Active NameNode对外提供服务，而Standby NameNode则不对外提供服务，仅同步active namenode的状态，以便能够在它失败时快速进行切换。<br><br>hadoop2.0官方提供了两种HDFS HA的解决方案，一种是NFS，另一种是QJM。这里我们使用简单的QJM。在该方案中，主备NameNode之间通过一组JournalNode同步元数据信息，一条数据只要成功写入多数JournalNode即认为写入成功。通常配置奇数个JournalNode<br>这里还配置了一个zookeeper集群，用于ZKFC（DFSZKFailoverController）故障转移，当Active NameNode挂掉了，会自动切换Standby NameNode为standby状态</p><p>2.hadoop-2.2.0中依然存在一个问题，就是ResourceManager只有一个，存在单点故障，hadoop-2.4.1解决了这个问题，有两个ResourceManager，一个是Active，一个是Standby，状态由zookeeper进行协调</p><h2 id="安装步骤："><a href="#安装步骤：" class="headerlink" title="安装步骤："></a>安装步骤：</h2><h3 id="1-安装配置zooekeeper集群（在nongyt05上）"><a href="#1-安装配置zooekeeper集群（在nongyt05上）" class="headerlink" title="1.安装配置zooekeeper集群（在nongyt05上）"></a>1.安装配置zooekeeper集群（在nongyt05上）</h3><pre><code>1.1解压    tar -zxvf zookeeper-3.4.5.tar.gz -C /nongyt/1.2修改配置    cd /nongyt/zookeeper-3.4.5/conf/    cp zoo_sample.cfg zoo.cfg    vim zoo.cfg    修改：dataDir=/nongyt/zookeeper-3.4.5/tmp    在最后添加：    server.1=nongyt05:2888:3888    server.2=nongyt06:2888:3888    server.3=nongyt07:2888:3888    保存退出    然后创建一个tmp文件夹    mkdir /nongyt/zookeeper-3.4.5/tmp    再创建一个空文件    touch /nongyt/zookeeper-3.4.5/tmp/myid    最后向该文件写入ID    echo 1 &gt; /nongyt/zookeeper-3.4.5/tmp/myid1.3将配置好的zookeeper拷贝到其他节点(首先分别在nongyt06、nongyt07根目录下创建一个nongyt目录：mkdir /nongyt)    scp -r /nongyt/zookeeper-3.4.5/ nongyt06:/nongyt/    scp -r /nongyt/zookeeper-3.4.5/ nongyt07:/nongyt/    注意：修改nongyt06、nongyt07对应/nongyt/zookeeper-3.4.5/tmp/myid内容    nongyt06：        echo 2 &gt; /nongyt/zookeeper-3.4.5/tmp/myid    nongyt07：        echo 3 &gt; /nongyt/zookeeper-3.4.5/tmp/myid</code></pre><h3 id="2-安装配置hadoop集群（在nongyt01上操作）"><a href="#2-安装配置hadoop集群（在nongyt01上操作）" class="headerlink" title="2.安装配置hadoop集群（在nongyt01上操作）"></a>2.安装配置hadoop集群（在nongyt01上操作）</h3><pre><code>    2.1解压        tar -zxvf hadoop-2.4.1.tar.gz -C /nongyt/    2.2配置HDFS（hadoop2.0所有的配置文件都在$HADOOP_HOME/etc/hadoop目录下）        #将hadoop添加到环境变量中        vim /etc/profile        export JAVA_HOME=/usr/java/jdk1.7.0_55        export HADOOP_HOME=/nongyt/hadoop-2.4.1        export PATH=$PATH:$JAVA_HOME/bin:$HADOOP_HOME/bin        #hadoop2.0的配置文件全部在$HADOOP_HOME/etc/hadoop下        cd /nongyt/hadoop-2.4.1/etc/hadoop        2.2.1修改hadoo-env.sh            export JAVA_HOME=/usr/java/jdk1.7.0_55        2.2.2修改core-site.xml            &lt;configuration&gt;                &lt;!-- 指定hdfs的nameservice为ns1 --&gt;                &lt;property&gt;                    &lt;name&gt;fs.defaultFS&lt;/name&gt;                    &lt;value&gt;hdfs://ns1&lt;/value&gt;                &lt;/property&gt;                &lt;!-- 指定hadoop临时目录 --&gt;                &lt;property&gt;                    &lt;name&gt;hadoop.tmp.dir&lt;/name&gt;                    &lt;value&gt;/nongyt/hadoop-2.4.1/tmp&lt;/value&gt;                &lt;/property&gt;                &lt;!-- 指定zookeeper地址 --&gt;                &lt;property&gt;                    &lt;name&gt;ha.zookeeper.quorum&lt;/name&gt;                    &lt;value&gt;nongyt05:2181,nongyt06:2181,nongyt07:2181&lt;/value&gt;                &lt;/property&gt;            &lt;/configuration&gt;        2.2.3修改hdfs-site.xml            &lt;configuration&gt;                &lt;!--指定hdfs的nameservice为ns1，需要和core-site.xml中的保持一致 --&gt;                &lt;property&gt;                    &lt;name&gt;dfs.nameservices&lt;/name&gt;                    &lt;value&gt;ns1&lt;/value&gt;                &lt;/property&gt;                &lt;!-- ns1下面有两个NameNode，分别是nn1，nn2 --&gt;                &lt;property&gt;                    &lt;name&gt;dfs.ha.namenodes.ns1&lt;/name&gt;                    &lt;value&gt;nn1,nn2&lt;/value&gt;                &lt;/property&gt;                &lt;!-- nn1的RPC通信地址 --&gt;                &lt;property&gt;                    &lt;name&gt;dfs.namenode.rpc-address.ns1.nn1&lt;/name&gt;                    &lt;value&gt;nongyt01:9000&lt;/value&gt;                &lt;/property&gt;                &lt;!-- nn1的http通信地址 --&gt;                &lt;property&gt;                    &lt;name&gt;dfs.namenode.http-address.ns1.nn1&lt;/name&gt;                    &lt;value&gt;nongyt01:50070&lt;/value&gt;                &lt;/property&gt;                &lt;!-- nn2的RPC通信地址 --&gt;                &lt;property&gt;                    &lt;name&gt;dfs.namenode.rpc-address.ns1.nn2&lt;/name&gt;                    &lt;value&gt;nongyt02:9000&lt;/value&gt;                &lt;/property&gt;                &lt;!-- nn2的http通信地址 --&gt;                &lt;property&gt;                    &lt;name&gt;dfs.namenode.http-address.ns1.nn2&lt;/name&gt;                    &lt;value&gt;nongyt02:50070&lt;/value&gt;                &lt;/property&gt;                &lt;!-- 指定NameNode的元数据在JournalNode上的存放位置 --&gt;                &lt;property&gt;                    &lt;name&gt;dfs.namenode.shared.edits.dir&lt;/name&gt;                    &lt;value&gt;qjournal://nongyt05:8485;nongyt06:8485;nongyt07:8485/ns1&lt;/value&gt;                &lt;/property&gt;                &lt;!-- 指定JournalNode在本地磁盘存放数据的位置 --&gt;                &lt;property&gt;                    &lt;name&gt;dfs.journalnode.edits.dir&lt;/name&gt;                    &lt;value&gt;/nongyt/hadoop-2.4.1/journal&lt;/value&gt;                &lt;/property&gt;                &lt;!-- 开启NameNode失败自动切换 --&gt;                &lt;property&gt;                    &lt;name&gt;dfs.ha.automatic-failover.enabled&lt;/name&gt;                    &lt;value&gt;true&lt;/value&gt;                &lt;/property&gt;                &lt;!-- 配置失败自动切换实现方式 --&gt;                &lt;property&gt;                    &lt;name&gt;dfs.client.failover.proxy.provider.ns1&lt;/name&gt;                    &lt;value&gt;org.apache.hadoop.hdfs.server.namenode.ha.ConfiguredFailoverProxyProvider&lt;/value&gt;                &lt;/property&gt;                &lt;!-- 配置隔离机制方法，多个机制用换行分割，即每个机制暂用一行--&gt;                &lt;property&gt;                    &lt;name&gt;dfs.ha.fencing.methods&lt;/name&gt;                    &lt;value&gt;                        sshfence                        shell(/bin/true)                    &lt;/value&gt;                &lt;/property&gt;                &lt;!-- 使用sshfence隔离机制时需要ssh免登陆 --&gt;                &lt;property&gt;                    &lt;name&gt;dfs.ha.fencing.ssh.private-key-files&lt;/name&gt;                    &lt;value&gt;/home/hadoop/.ssh/id_rsa&lt;/value&gt;                &lt;/property&gt;                &lt;!-- 配置sshfence隔离机制超时时间 --&gt;                &lt;property&gt;                    &lt;name&gt;dfs.ha.fencing.ssh.connect-timeout&lt;/name&gt;                    &lt;value&gt;30000&lt;/value&gt;                &lt;/property&gt;            &lt;/configuration&gt;        2.2.4修改mapred-site.xml            &lt;configuration&gt;                &lt;!-- 指定mr框架为yarn方式 --&gt;                &lt;property&gt;                    &lt;name&gt;mapreduce.framework.name&lt;/name&gt;                    &lt;value&gt;yarn&lt;/value&gt;                &lt;/property&gt;            &lt;/configuration&gt;            2.2.5修改yarn-site.xml            &lt;configuration&gt;                &lt;!-- 开启RM高可靠 --&gt;                &lt;property&gt;                   &lt;name&gt;yarn.resourcemanager.ha.enabled&lt;/name&gt;                   &lt;value&gt;true&lt;/value&gt;                &lt;/property&gt;                &lt;!-- 指定RM的cluster id --&gt;                &lt;property&gt;                   &lt;name&gt;yarn.resourcemanager.cluster-id&lt;/name&gt;                   &lt;value&gt;yrc&lt;/value&gt;                &lt;/property&gt;                &lt;!-- 指定RM的名字 --&gt;                &lt;property&gt;                   &lt;name&gt;yarn.resourcemanager.ha.rm-ids&lt;/name&gt;                   &lt;value&gt;rm1,rm2&lt;/value&gt;                &lt;/property&gt;                &lt;!-- 分别指定RM的地址 --&gt;                &lt;property&gt;                   &lt;name&gt;yarn.resourcemanager.hostname.rm1&lt;/name&gt;                   &lt;value&gt;nongyt03&lt;/value&gt;                &lt;/property&gt;                &lt;property&gt;                   &lt;name&gt;yarn.resourcemanager.hostname.rm2&lt;/name&gt;                   &lt;value&gt;nongyt04&lt;/value&gt;                &lt;/property&gt;                &lt;!-- 指定zk集群地址 --&gt;                &lt;property&gt;                   &lt;name&gt;yarn.resourcemanager.zk-address&lt;/name&gt;                   &lt;value&gt;nongyt05:2181,nongyt06:2181,nongyt07:2181&lt;/value&gt;                &lt;/property&gt;                &lt;property&gt;                   &lt;name&gt;yarn.nodemanager.aux-services&lt;/name&gt;                   &lt;value&gt;mapreduce_shuffle&lt;/value&gt;                &lt;/property&gt;            &lt;/configuration&gt;        2.2.6修改slaves(slaves是指定子节点的位置，因为要在nongyt01上启动HDFS、在nongyt03启动yarn，所以nongyt01上的slaves文件指定的是datanode的位置，nongyt03上的slaves文件指定的是nodemanager的位置)            nongyt05            nongyt06            nongyt07        2.2.7配置免密码登陆            #首先要配置nongyt01到nongyt02、nongyt03、nongyt04、nongyt05、nongyt06、nongyt07的免密码登陆            #在nongyt01上生产一对钥匙            ssh-keygen -t rsa            #将公钥拷贝到其他节点，包括自己            ssh-coyp-id nongyt01            ssh-coyp-id nongyt02            ssh-coyp-id nongyt03            ssh-coyp-id nongyt04            ssh-coyp-id nongyt05            ssh-coyp-id nongyt06            ssh-coyp-id nongyt07            #配置nongyt03到nongyt04、nongyt05、nongyt06、nongyt07的免密码登陆            #在nongyt03上生产一对钥匙            ssh-keygen -t rsa            #将公钥拷贝到其他节点            ssh-coyp-id nongyt04            ssh-coyp-id nongyt05            ssh-coyp-id nongyt06            ssh-coyp-id nongyt07            #注意：两个namenode之间要配置ssh免密码登陆，别忘了配置nongyt02到nongyt01的免登陆            在nongyt02上生产一对钥匙            ssh-keygen -t rsa            ssh-coyp-id -i nongyt01                    2.4将配置好的hadoop拷贝到其他节点        scp -r /nongyt/ nongyt02:/        scp -r /nongyt/ nongyt03:/        scp -r /nongyt/hadoop-2.4.1/ root@nongyt04:/nongyt/        scp -r /nongyt/hadoop-2.4.1/ root@nongyt05:/nongyt/        scp -r /nongyt/hadoop-2.4.1/ root@nongyt06:/nongyt/        scp -r /nongyt/hadoop-2.4.1/ root@nongyt07:/nongyt/    ###注意：严格按照下面的步骤    2.5启动zookeeper集群（分别在nongyt05、nongyt06、tcast07上启动zk）        cd /nongyt/zookeeper-3.4.5/bin/        ./zkServer.sh start        #查看状态：一个leader，两个follower        ./zkServer.sh status    2.6启动journalnode（分别在在nongyt05、nongyt06、tcast07上执行）        cd /nongyt/hadoop-2.4.1        sbin/hadoop-daemon.sh start journalnode        #运行jps命令检验，nongyt05、nongyt06、nongyt07上多了JournalNode进程    2.7格式化HDFS        #在nongyt01上执行命令:        hdfs namenode -format        #格式化后会在根据core-site.xml中的hadoop.tmp.dir配置生成个文件，这里我配置的是/nongyt/hadoop-2.4.1/tmp，然后将/nongyt/hadoop-2.4.1/tmp拷贝到nongyt02的/nongyt/hadoop-2.4.1/下。        scp -r tmp/ nongyt02:/nongyt/hadoop-2.4.1/    2.8格式化ZK(在nongyt01上执行即可)        hdfs zkfc -formatZK    2.9启动HDFS(在nongyt01上执行)        sbin/start-dfs.sh    2.10启动YARN(#####注意#####：是在nongyt03上执行start-yarn.sh，把namenode和resourcemanager分开是因为性能问题，因为他们都要占用大量资源，所以把他们分开了，他们分开了就要分别在不同的机器上启动)        sbin/start-yarn.sh到此，hadoop-2.4.1配置完毕，可以统计浏览器访问:    http://192.168.1.201:50070    NameNode &apos;nongyt01:9000&apos; (active)    http://192.168.1.202:50070    NameNode &apos;nongyt02:9000&apos; (standby)验证HDFS HA    首先向hdfs上传一个文件    hadoop fs -put /etc/profile /profile    hadoop fs -ls /    然后再kill掉active的NameNode    kill -9 &lt;pid of NN&gt;    通过浏览器访问：http://192.168.1.202:50070    NameNode &apos;nongyt02:9000&apos; (active)    这个时候nongyt02上的NameNode变成了active    在执行命令：    hadoop fs -ls /    -rw-r--r--   3 root supergroup       1926 2014-02-06 15:36 /profile    刚才上传的文件依然存在！！！    手动启动那个挂掉的NameNode    sbin/hadoop-daemon.sh start namenode    通过浏览器访问：http://192.168.1.201:50070    NameNode &apos;nongyt01:9000&apos; (standby)验证YARN：    运行一下hadoop提供的demo中的WordCount程序：    hadoop jar share/hadoop/mapreduce/hadoop-mapreduce-examples-2.4.1.jar wordcount /profile /outOK，大功告成！！！</code></pre><h2 id="zookeeper配置文件详解"><a href="#zookeeper配置文件详解" class="headerlink" title="zookeeper配置文件详解"></a>zookeeper配置文件详解</h2><p>zookeeper的默认配置文件为zookeeper/conf/zoo_sample.cfg，需要将其修改为zoo.cfg。其中各配置项的含义，解释如下：</p><ul><li><p>1.tickTime：CS通信心跳时间<br><br>Zookeeper 服务器之间或客户端与服务器之间维持心跳的时间间隔，也就是每个 tickTime 时间就会发送一个心跳。tickTime以毫秒为单位。<br><br>tickTime=2000  </p></li><li><p>2.initLimit：LF初始通信时限<br><br>集群中的follower服务器(F)与leader服务器(L)之间初始连接时能容忍的最多心跳数（tickTime的数量）。<br><br>initLimit=5  </p></li><li><p>3.syncLimit：LF同步通信时限<br><br>集群中的follower服务器与leader服务器之间请求和应答之间能容忍的最多心跳数（tickTime的数量）。<br><br>syncLimit=2  </p></li><li><p>4.dataDir：数据文件目录<br><br>Zookeeper保存数据的目录，默认情况下，Zookeeper将写数据的日志文件也保存在这个目录里。<br>dataDir=/home/michael/opt/zookeeper/data  </p></li><li><p>5.clientPort：客户端连接端口<br><br>客户端连接 Zookeeper 服务器的端口，Zookeeper 会监听这个端口，接受客户端的访问请求。<br><br>clientPort=2181 </p></li><li><p>6.服务器名称与地址：<br><br>  集群信息（服务器编号，服务器地址，LF通信端口，选举端口）<br><br>  这个配置项的书写格式比较特殊，规则如下：<br><br>  server.N=YYY:A:B <br><br>  server.1=nongyt05:2888:3888<br><br>  server.2=nongyt06:2888:3888<br><br>  server.3=nongyt07:2888:3888<br></p></li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> hadoop </tag>
            
            <tag> zookeeper </tag>
            
            <tag> cluster </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Linux下tomcat启动慢的问题</title>
      <link href="/2017/10/24/Linux%E4%B8%8Btomcat%E5%90%AF%E5%8A%A8%E6%85%A2%E7%9A%84%E9%97%AE%E9%A2%98/"/>
      <url>/2017/10/24/Linux%E4%B8%8Btomcat%E5%90%AF%E5%8A%A8%E6%85%A2%E7%9A%84%E9%97%AE%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<h2 id="有两种解决办法："><a href="#有两种解决办法：" class="headerlink" title="有两种解决办法："></a>有两种解决办法：</h2><p>1）在Tomcat环境中解决</p><p>可以通过配置JRE使用非阻塞的Entropy Source。<br>在catalina.sh中加入这么一行：-Djava.security.egd=file:/dev/./urandom 即可。<br>加入后再启动Tomcat，整个启动耗时下降到Server startup in 2912 ms。<br><a id="more"></a><br>2）在JVM环境中解决</p><p>打开$JAVA_PATH/jre/lib/security/java.security这个文件，找到下面的内容：<br><br>securerandom.source=file:/dev/urandom<br>替换成<br>securerandom.source=file:/dev/./urandom</p><h2 id="彻底解决"><a href="#彻底解决" class="headerlink" title="彻底解决"></a>彻底解决</h2><p>“Linux下的所有应用程序产生随机数都会用到这个，所以不仅仅是Tomcat可能被 阻塞 。如果你搜索会发现Apache、Nginx、OpenSSL都被这个问题坑过.”<br>由于《彻底找到Tomcat启动速度慢的元凶》这篇原文网上被引用过多，我也分不清那个是原文，所以此处就不贴原文地址了，大家可自行百度关键字：彻底找到Tomcat启动速度慢的元凶</p>]]></content>
      
      
      
        <tags>
            
            <tag> tomcat </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>HDFS架构及其执行原理</title>
      <link href="/2017/10/18/HDFS%E6%9E%B6%E6%9E%84%E6%9E%81%E5%85%B6%E6%89%A7%E8%A1%8C%E5%8E%9F%E7%90%86/"/>
      <url>/2017/10/18/HDFS%E6%9E%B6%E6%9E%84%E6%9E%81%E5%85%B6%E6%89%A7%E8%A1%8C%E5%8E%9F%E7%90%86/</url>
      
        <content type="html"><![CDATA[<h2 id="一、前言："><a href="#一、前言：" class="headerlink" title="一、前言："></a>一、前言：</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;HDFS和YARN作为hadoop的核心，前者用于海量数据的存储，后者负责资源管理调度。本文先对HDFS，就个人的掌握的程度进行简单的概要和回顾。关于 YARN结构以及内部执行原理，以及后面内部各个组件如何相互协调工作，后面再进行探讨。</p><h3 id="1-1、名词复习"><a href="#1-1、名词复习" class="headerlink" title="1.1、名词复习"></a>1.1、名词复习</h3><p> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;1）、YARN ——Yet Another Resource Negotiator（资源管理调度系统）<br><br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;2）、HDFS——Hadoop Distributed File System（分布式文件系统）</p><pre><code>内部主从结构•主节点，只有一个: namenode•从节点，有很多个: datanode</code></pre><p> <strong>namenode负责：</strong><br><br><a id="more"></a></p><ul><li>接收用户操作请求</li><li>维护文件系统的目录结构</li><li><p>管理文件与block之间关系，block与datanode之间关系<br></p><p><strong>datanode负责：</strong></p></li><li><p>存储文件</p></li><li>文件被分成block存储在磁盘上</li><li>为保证数据安全，文件会有多个副本</li></ul><p>备注：还有另外一个SecondaryNameNode，作为NameNode的辅助组件，但是不能替代NameNode，下面会简单的介绍。</p><h3 id="1-2、Hadoop1-0和hadop2-0的对比"><a href="#1-2、Hadoop1-0和hadop2-0的对比" class="headerlink" title="1.2、Hadoop1.0和hadop2.0的对比"></a>1.2、Hadoop1.0和hadop2.0的对比</h3><p><img src="https://raw.githubusercontent.com/tokerr/markdownImage/master/HDFS%E6%9E%B6%E6%9E%84%E6%9E%81%E5%85%B6%E6%89%A7%E8%A1%8C%E5%8E%9F%E7%90%86/1.png" alt=""></p><h2 id="二、分布式文件系统与HDFS"><a href="#二、分布式文件系统与HDFS" class="headerlink" title="二、分布式文件系统与HDFS"></a>二、分布式文件系统与HDFS</h2><ul><li><p>数据量越来越多，在一个操作系统管辖的范围存不下了，那么就分配到更多的操作系统管理的磁盘中，但是不方便管理和维护，因此迫切需要一种系统来管理多台机器上的文件，这就是分布式文件管理系统 。</p></li><li><p>是一种允许文件通过网络在多台主机上分享的文件系统，可让多机器上的多用户分享文件和存储空间。</p></li><li><p>通透性。让实际上是通过网络来访问文件的动作，由程序与用户看来，就像是访问本地的磁盘一般。</p></li><li><p>容错。即使系统中有某些节点脱机，整体来说系统仍然可以持续运作而不会有数据损失。</p></li><li><p>分布式文件管理系统很多，hdfs只是其中一种。适用于一次写入多次查询的情况，不支持并发写情况，小文件不合适。</p></li></ul><h2 id="三、HDFS体系结构与基本概念"><a href="#三、HDFS体系结构与基本概念" class="headerlink" title="三、HDFS体系结构与基本概念"></a>三、HDFS体系结构与基本概念</h2><h3 id="3-1-HDFS架构"><a href="#3-1-HDFS架构" class="headerlink" title="3.1 HDFS架构"></a>3.1 HDFS架构</h3><p>包括NameNode，DataNode，Secondary NameNode</p><h3 id="3-2-原理图"><a href="#3-2-原理图" class="headerlink" title="3.2 原理图"></a>3.2 原理图</h3><p><img src="https://raw.githubusercontent.com/tokerr/markdownImage/master/HDFS%E6%9E%B6%E6%9E%84%E6%9E%81%E5%85%B6%E6%89%A7%E8%A1%8C%E5%8E%9F%E7%90%86/2.jpg" alt=""></p><h3 id="3-3-NameNode"><a href="#3-3-NameNode" class="headerlink" title="3.3 NameNode"></a>3.3 NameNode</h3><p>是整个文件系统的管理节点。它维护着整个文件系统的文件目录树，文件/目录的元信息和每个文件对应的数据块列表。接收用户的操作请求。</p><pre><code>文件包括(hdfs-site.xml的dfs.name.dir属性)：fsimage:元数据镜像文件。存储某一时段NameNode内存元数据信息。edits:操作日志文件。fstime:保存最近一次checkpoint的时间以上这些文件是保存在linux的文件系统中。</code></pre><p>NameNode工作特点：</p><ul><li>Namenode始终在内存中保存metedata，用于处理“读请求”</li><li>到有“写请求”到来时，namenode会首先写editlog到磁盘，即向edits文件中写日志，成功返回后，才会修改内存，并且向客户端返回</li><li>Hadoop会维护一个fsimage文件，也就是namenode中metedata的镜像，但是fsimage不会随时与namenode内存中的metedata保持一致，而是每隔一段时间通过合并edits文件来更新内容。Secondary namenode就是用来合并fsimage和edits文件来更新NameNode的metedata的。</li></ul><h3 id="3-4-SecondaryNameNode"><a href="#3-4-SecondaryNameNode" class="headerlink" title="3.4 SecondaryNameNode"></a>3.4 SecondaryNameNode</h3><ul><li>HA的一个解决方案。但不支持热备。配置即可。</li><li>执行过程：从NameNode上下载元数据信息（fsimage,edits），然后把二者合并，生成新的fsimage，在本地保存，并将其推送到NameNode，替换旧的fsimage.</li><li>默认在安装在NameNode节点上，但这样…不安全！</li></ul><p>SecondaryNameNode工作流程：</p><ol><li>secondary通知namenode切换edits文件</li><li>secondary从namenode获得fsimage和edits(通过http)</li><li>secondary将fsimage载入内存，然后开始合并edits</li><li>secondary将新的fsimage发回给namenode</li><li>namenode用新的fsimage替换旧的fsimage</li></ol><p>下图是NameNode和SecondaryNameNode工作相互协调的过程：<br><img src="https://raw.githubusercontent.com/tokerr/markdownImage/master/HDFS%E6%9E%B6%E6%9E%84%E6%9E%81%E5%85%B6%E6%89%A7%E8%A1%8C%E5%8E%9F%E7%90%86/3.png" alt=""></p><h3 id="3-5-DataNode"><a href="#3-5-DataNode" class="headerlink" title="3.5 DataNode"></a>3.5 DataNode</h3><ul><li>提供真实文件数据的存储服务。</li><li>文件块（block）：最基本的存储单位。对于文件内容而言，一个文件的长度大小是size，那么从文件的０偏移开始，按照固定的大小，顺序对文件进行划分并编号，划分好的每一个块称一个Block。HDFS默认Block大小是128MB，以一个256MB文件，共有256/128=2个Block.</li><li>不同于普通文件系统的是，HDFS中，如果一个文件小于一个数据块的大小，并不占用整个数据块存储空间</li><li>Replication。多复本。默认是三个。</li></ul><h2 id="四、HDFS的shell操作"><a href="#四、HDFS的shell操作" class="headerlink" title="四、HDFS的shell操作"></a>四、HDFS的shell操作</h2><ul><li>调用文件系统(FS)Shell命令应使用bin/hadoop fs 的形式。</li><li>所有的FS shell命令使用URI路径作为参数。</li><li>URI格式是scheme://authority/。HDFS的scheme是hdfs，对本地文件系统，scheme是file。其中scheme和authority参数都是可选的，如果未加指定，就会使用配置中指定的默认scheme。</li><li>例如：/parent/child可以表示成hdfs://namenode:namenodePort/parent/child，或者更简单的/parent/child（假设配置文件是namenode:namenodePort）</li><li>大多数FS Shell命令的行为和对应的Unix Shell命令类似。</li></ul><p>HDFS   fs命令</p><pre><code>-help [cmd]    //显示命令的帮助信息-ls(r) &lt;path&gt;    //显示当前目录下所有文件-du(s) &lt;path&gt;    //显示目录中所有文件大小-count[-q] &lt;path&gt;    //显示目录中文件数量-mv &lt;src&gt; &lt;dst&gt;    //移动多个文件到目标目录-cp &lt;src&gt; &lt;dst&gt;    //复制多个文件到目标目录-rm(r)        //删除文件(夹)-put &lt;localsrc&gt; &lt;dst&gt;    //本地文件复制到hdfs-copyFromLocal    //同put-moveFromLocal    //从本地文件移动到hdfs-get [-ignoreCrc] &lt;src&gt; &lt;localdst&gt;    //复制文件到本地，可以忽略crc校验-getmerge &lt;src&gt; &lt;localdst&gt;        //将源目录中的所有文件排序合并到一个文件中-cat &lt;src&gt;    //在终端显示文件内容-text &lt;src&gt;    //在终端显示文件内容-copyToLocal [-ignoreCrc] &lt;src&gt; &lt;localdst&gt;    //复制到本地-moveToLocal &lt;src&gt; &lt;localdst&gt;-mkdir &lt;path&gt;    //创建文件夹-touchz &lt;path&gt;    //创建一个空文件</code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> hadoop </tag>
            
            <tag> HDFS </tag>
            
            <tag> YARN </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Shuffle工作机制</title>
      <link href="/2017/10/16/Shuffle%E5%B7%A5%E4%BD%9C%E6%9C%BA%E5%88%B6/"/>
      <url>/2017/10/16/Shuffle%E5%B7%A5%E4%BD%9C%E6%9C%BA%E5%88%B6/</url>
      
        <content type="html"><![CDATA[<h2 id="一、前言"><a href="#一、前言" class="headerlink" title="一、前言"></a>一、前言</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;MapReduce 是现今一个非常流行的分布式计算框架，它被设计用于并行计算海量数据。第一个提出该技术框架的是Google 公司，而Google 的灵感则来自于函数式编程语言，如LISP，Scheme，ML 等。<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;MapReduce 框架的核心步骤主要分两部分：Map 和Reduce。当你向MapReduce 框架提交一个计算作业时，它会首先把计算作业拆分成若干个Map 任务，然后分配到不同的节点上去执行，每一个Map 任务处理输入数据中的一部分，当Map 任务完成后，它会生成一些中间文件，这些中间文件将会作为Reduce 任务的输入数据。Reduce 任务的主要目标就是把前面若干个Map 的输出汇总到一起并输出。<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Shuffle作为MapReducer的”心脏”，本文主要是对此做一次总结，只对其工作机制进行简单的概要，以便回顾，不涉及代码部分。</p><h2 id="二、什么是Shuffle"><a href="#二、什么是Shuffle" class="headerlink" title="二、什么是Shuffle?"></a>二、什么是Shuffle?</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;MapReducer确保每个reducer的输入（也就是map的输出）都按键排序。将map task的输出结果 传给reducer(作为reducer输入) 的过程，称之为shuffle，参考下面这张MapReducer的工作流程机制，这个过程会经历排序和分区。<br><img src="https://raw.githubusercontent.com/tokerr/markdownImage/master/Shuffle%E5%B7%A5%E4%BD%9C%E6%9C%BA%E5%88%B6/1.png" alt="MapReducer执行原理"><br><a id="more"></a></p><h2 id="三、Shuffle工作机制："><a href="#三、Shuffle工作机制：" class="headerlink" title="三、Shuffle工作机制："></a>三、Shuffle工作机制：</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;从map端的输出开始。map函数开始产生输出时，不是简单地将它写到磁盘。这个过程更复杂，它利用缓冲的方式写到内存，井出于效率的考虑进行预排序。下图展示了这个过程每个map任务都有一个环形内存缓冲区，用于存储任务的输出。默认情况下，缓冲区的大为100MB，此值可以通过改变io.sort.mb属性来调整。一旦缓冲内容达到闹值(io.sort.spill.percent，默认为0.80，或80%)，一个后台线程便开始把内容写到(spill)磁盘中。在写磁盘过程中，map输出继续被写到缓冲区，但如果在此期间缓冲区被填楠，map会阻塞直到写磁盘过程完成。写磁盘将按轮询方式写到mapred.local.dir属性指定的作业特定子目录中的目录中。<br><br><img src="https://raw.githubusercontent.com/tokerr/markdownImage/master/Shuffle%E5%B7%A5%E4%BD%9C%E6%9C%BA%E5%88%B6/2.png" alt="Shuffle工作机制"></p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在map输出写磁盘之前，线程首先根据数据最终要传送到的reducer把数据划分成相应的分区(partition)。在每个分区中，后台线程按键进行内排序，如果有一个combiner，它会在排序后的输出上运行。<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;一旦内存缓冲区达到溢出写的阀值，就会新建一个溢出写文件，因此在map任务写完其最后一个输出记录之后，会有几个溢出写文件。在任务完成之前，溢出写文件被合并成一个已分区且已排序的输出文件。配置属性io.sort.factor控制着一次最多能合并多少流，默认值是10.<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;如果已经指定combiner，并且溢出写次数至少为3(min.num.spills.for.combine属性的取值)肘，则combiner就会在输出文件写到磁盘之前运行。combiner可以在输入上反复运行，如果combiner可拔插，添加Combiner绝不能改变最终的计算结果;不排除使用combiner作为在map端过滤数据的用途，比如空字符串或者其他无效的参数，这会影响reducer的计算结果。运行combiner的意义在于使map输出更紧凑，使得写到本地磁盘和传给reducer的数据更少。写盘时压缩map输出可以提高效率，因为这样会让写磁盘的速度更快，节约磁盘空间，并且减少传给reducer的数据量。默认情况下，输出是不压缩的，但只要将mapred.compress.map.output设置为true，就可以启用此功能。使用的压缩库库mapred.map.output.compression.codec指定.<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;最后，reducer通过HTTP方式得到输出文件的分区。</p>]]></content>
      
      
      
        <tags>
            
            <tag> hadoop </tag>
            
            <tag> MapReducer </tag>
            
            <tag> Shuffle </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Jquery防止Ajax重复提交解决方案</title>
      <link href="/2017/10/09/Jquery%E9%98%B2%E6%AD%A2Ajax%E9%87%8D%E5%A4%8D%E6%8F%90%E4%BA%A4%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/"/>
      <url>/2017/10/09/Jquery%E9%98%B2%E6%AD%A2Ajax%E9%87%8D%E5%A4%8D%E6%8F%90%E4%BA%A4%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/</url>
      
        <content type="html"><![CDATA[<h3 id="一、前言"><a href="#一、前言" class="headerlink" title="一、前言"></a>一、前言</h3><p>不同于全页面刷新的表单提交，以下方法通过jquery实现ajax的防止重复提交。</p><h2 id="二、直接上代码"><a href="#二、直接上代码" class="headerlink" title="二、直接上代码"></a>二、直接上代码</h2><pre><code>/*** jquery ajax请求过滤，防止ajax请求重复发送，对ajax发送错误时进行统一处理*/$(function(){var pendingRequests = {};// 所有ajax请求的通用前置filter$.ajaxPrefilter(function( options, originalOptions, jqXHR ) {var key = generatePendingRequestKey(options);</code></pre><a id="more"></a>    <pre><code>//请求是否已经存在if(!pendingRequests[key]){storePendingRequest(key,jqXHR);}else{//如果ajax请求已经存在，下一次相同的请求则取消，防止重复请求jqXHR.abort();}//ajax请求完成时，从临时对象中清除请求对应的数据var complete = options.complete;options.complete = function(jqXHR, textStatus) {//延时1000毫秒删除请求信息，表示同Key值请求不能在此时间段内重复提交setTimeout(function(){delete pendingRequests[jqXHR.pendingRequestKey];},1000);if ($.isFunction(complete)) {complete.apply(this, arguments);}};//统一的错误处理var error = options.error;options.error = function(jqXHR, textStatus) {errorHandler(jqXHR, textStatus);if ($.isFunction(error)) {error.apply(this, arguments);}};});/*** 当ajax请求发生错误时，统一进行拦截处理的方法*/function errorHandler(jqXHR, textStatus){switch (jqXHR.status){case(500):internalError(jqXHR);break;case(403):accessDenied(jqXHR);break;case(408):timeoutError(jqXHR);break;case(404):pageNotFound(jqXHR);break;default://otherError(jqXHR, textStatus);}}function pageNotFound(jqXHR){Component.warningMessageBox({content:&quot;请求访问的地址或内容不存在！&quot;});}function accessDenied(jqXHR){Component.warningMessageBox({content:&quot;你无权进行此操作或页面访问！&quot;});}function internalError(jqXHR){Component.warningMessageBox({content:&quot;服务器存在错误，未能正确处理你的请求！&quot;});}function timeoutError(jqXHR){window.location.href=contextPath + &quot;/j_spring_security_logout&quot;;}function otherError(jqXHR, textStatus){Component.warningMessageBox({content:&quot;未知错误，错误代码：&quot; + textStatus});}/*** 将ajax请求存储到临时对象中，用于根据key判断请求是否已经存在*/function storePendingRequest(key, jqXHR){pendingRequests[key] = jqXHR;jqXHR.pendingRequestKey = key;}/*** 根据ajax请求参数构建一个临时存储key,此处简单的使用url作为key，* 不考虑为解决请求类型为get时相同路径引起的缓存问题，采用随机码构建URL的情况*/function generatePendingRequestKey(options){return options.url;}});</code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> jquery </tag>
            
            <tag> ajax </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>子查询的方式实现sql语句的先排序后分组</title>
      <link href="/2017/06/22/%E5%AD%90%E6%9F%A5%E8%AF%A2%E7%9A%84%E6%96%B9%E5%BC%8F%E5%AE%9E%E7%8E%B0sql%E8%AF%AD%E5%8F%A5%E7%9A%84%E5%85%88%E6%8E%92%E5%BA%8F%E5%90%8E%E5%88%86%E7%BB%84/"/>
      <url>/2017/06/22/%E5%AD%90%E6%9F%A5%E8%AF%A2%E7%9A%84%E6%96%B9%E5%BC%8F%E5%AE%9E%E7%8E%B0sql%E8%AF%AD%E5%8F%A5%E7%9A%84%E5%85%88%E6%8E%92%E5%BA%8F%E5%90%8E%E5%88%86%E7%BB%84/</url>
      
        <content type="html"><![CDATA[<h3 id="需求："><a href="#需求：" class="headerlink" title="需求："></a>需求：</h3><p>查询学生表当中每一门课程成绩最高的记录。</p><h3 id="思路："><a href="#思路：" class="headerlink" title="思路："></a>思路：</h3><p>先按分数对记录进行降序，然后按照课程进行分组即可实现。<br><a id="more"></a><br>Student表结构：<br><br><img src="https://raw.githubusercontent.com/tokerr/markdownImage/master/%E5%AD%90%E6%9F%A5%E8%AF%A2%E7%9A%84%E6%96%B9%E5%BC%8F%E5%AE%9E%E7%8E%B0sql%E8%AF%AD%E5%8F%A5%E7%9A%84%E5%85%88%E6%8E%92%E5%BA%8F%E5%90%8E%E5%88%86%E7%BB%84/1.png" alt=""></p><p>现在手动添加如下数据进去：<br><br><img src="https://raw.githubusercontent.com/tokerr/markdownImage/master/%E5%AD%90%E6%9F%A5%E8%AF%A2%E7%9A%84%E6%96%B9%E5%BC%8F%E5%AE%9E%E7%8E%B0sql%E8%AF%AD%E5%8F%A5%E7%9A%84%E5%85%88%E6%8E%92%E5%BA%8F%E5%90%8E%E5%88%86%E7%BB%84/2.png" alt=""></p><p>起初，按照原来的思路，我编写的sql语句如下图(第一句)，得到的结果却不是我们想要的，可以看到group by字句先于Order by执行了，效果如图(下一部分)：<br><br><img src="https://raw.githubusercontent.com/tokerr/markdownImage/master/%E5%AD%90%E6%9F%A5%E8%AF%A2%E7%9A%84%E6%96%B9%E5%BC%8F%E5%AE%9E%E7%8E%B0sql%E8%AF%AD%E5%8F%A5%E7%9A%84%E5%85%88%E6%8E%92%E5%BA%8F%E5%90%8E%E5%88%86%E7%BB%84/3.png" alt=""></p><p>因此，使用子查询的方式先对数据进行降序，对新的结果集给一个别名，然后再按课程进行分组，如下：<br><br><img src="https://raw.githubusercontent.com/tokerr/markdownImage/master/%E5%AD%90%E6%9F%A5%E8%AF%A2%E7%9A%84%E6%96%B9%E5%BC%8F%E5%AE%9E%E7%8E%B0sql%E8%AF%AD%E5%8F%A5%E7%9A%84%E5%85%88%E6%8E%92%E5%BA%8F%E5%90%8E%E5%88%86%E7%BB%84/4.png" alt=""></p>]]></content>
      
      
      
        <tags>
            
            <tag> sql </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>String类型两种创建对象的方式的内存分配</title>
      <link href="/2017/06/04/String%E7%B1%BB%E5%9E%8B%E4%B8%A4%E7%A7%8D%E5%88%9B%E5%BB%BA%E5%AF%B9%E8%B1%A1%E7%9A%84%E6%96%B9%E5%BC%8F%E7%9A%84%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D/"/>
      <url>/2017/06/04/String%E7%B1%BB%E5%9E%8B%E4%B8%A4%E7%A7%8D%E5%88%9B%E5%BB%BA%E5%AF%B9%E8%B1%A1%E7%9A%84%E6%96%B9%E5%BC%8F%E7%9A%84%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D/</url>
      
        <content type="html"><![CDATA[<h3 id="一张图就可以看明白"><a href="#一张图就可以看明白" class="headerlink" title="一张图就可以看明白"></a>一张图就可以看明白</h3><p><img src="https://raw.githubusercontent.com/tokerr/markdownImage/master/String%E7%B1%BB%E5%9E%8B%E4%B8%A4%E7%A7%8D%E5%88%9B%E5%BB%BA%E5%AF%B9%E8%B1%A1%E7%9A%84%E6%96%B9%E5%BC%8F%E7%9A%84%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D/%E5%AD%97%E7%AC%A6%E4%B8%B2%20%E7%9A%84%E5%88%9B%E5%BB%BA%E6%96%B9%E5%BC%8F.png" alt=""></p>]]></content>
      
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> String </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Java运行时异常和非运行时异常</title>
      <link href="/2017/05/28/Java%E8%BF%90%E8%A1%8C%E6%97%B6%E5%BC%82%E5%B8%B8%E5%92%8C%E9%9D%9E%E8%BF%90%E8%A1%8C%E6%97%B6%E5%BC%82%E5%B8%B8/"/>
      <url>/2017/05/28/Java%E8%BF%90%E8%A1%8C%E6%97%B6%E5%BC%82%E5%B8%B8%E5%92%8C%E9%9D%9E%E8%BF%90%E8%A1%8C%E6%97%B6%E5%BC%82%E5%B8%B8/</url>
      
        <content type="html"><![CDATA[<h1 id="1-Java异常机制"><a href="#1-Java异常机制" class="headerlink" title="1.Java异常机制"></a>1.Java异常机制</h1><p>Java把异常当做对象来处理，并定义一个基类java.lang.Throwable作为所有异常的超类。Java中的异常分为两大类：错误Error和异常Exception，Java异常体系结构如下图所示：<br><img src="https://raw.githubusercontent.com/tokerr/markdownImage/master/Java%E8%BF%90%E8%A1%8C%E6%97%B6%E5%BC%82%E5%B8%B8%E5%92%8C%E9%9D%9E%E8%BF%90%E8%A1%8C%E6%97%B6%E5%BC%82%E5%B8%B8/Image.jpg" alt=""></p><h1 id="2-Throwable"><a href="#2-Throwable" class="headerlink" title="2.Throwable"></a>2.Throwable</h1><p>Throwable类是所有异常或错误的超类，它有两个子类：Error和Exception，分别表示错误和异常。其中异常Exception分为运行时异常(RuntimeException)和非运行时异常，也称之为不检查异常(Unchecked Exception)和检查异常(Checked Exception)。</p><h1 id="3-Error"><a href="#3-Error" class="headerlink" title="3.Error"></a>3.Error</h1><p>一般是指java虚拟机相关的问题，如系统崩溃、虚拟机出错误、动态链接失败等，这种错误无法恢复或不可能捕获，将导致应用程序中断，通常应用程序无法处理这些错误，因此应用程序不应该捕获Error对象，也无须在其throws子句中声明该方法抛出任何Error或其子类。<br><a id="more"></a></p><h1 id="4-可查异常和不可查异常"><a href="#4-可查异常和不可查异常" class="headerlink" title="4.可查异常和不可查异常"></a>4.可查异常和不可查异常</h1><p>通常，Java的异常(包括Exception和Error)分为可查的异常（checked exceptions）和不可查的异常（unchecked exceptions）。<br>可查异常（编译器要求必须处置的异常）：正确的程序在运行中，很容易出现的、情理可容的异常状况。可查异常虽然是异常状况，但在一定程度上它的发生是可以预计的，而且一旦发生这种异常状况，就必须采取某种方式进行处理。<br>除了RuntimeException及其子类以外，其他的Exception类及其子类都属于可查异常。这种异常的特点是Java编译器会检查它，也就是说，当程序中可能出现这类异常，要么用try-catch语句捕获它，要么用throws子句声明抛出它，否则编译不会通过。<br>不可查异常(编译器不要求强制处置的异常):包括运行时异常（RuntimeException与其子类）和错误（Error）。<br>如果使用throw在方法体中抛出可查异常，则需要在方法头部声明方法可能抛出的异常类型。程序会在throw语句后立即终止，它后面的语句执行不到，然后在包含它的所有try块中（可能在上层调用函数中）从里向外寻找含有与其匹配的catch子句的try块。</p><h1 id="5-运行时异常和非运行时异常"><a href="#5-运行时异常和非运行时异常" class="headerlink" title="5.运行时异常和非运行时异常"></a>5.运行时异常和非运行时异常</h1><p>(1)运行时异常都是RuntimeException类及其子类异常，如NullPointerException、IndexOutOfBoundsException等，这些异常是不检查异常，程序中可以选择捕获处理，也可以不处理。这些异常一般是由程序逻辑错误引起的，程序应该从逻辑角度尽可能避免这类异常的发生。<br>当出现RuntimeException的时候，我们可以不处理。当出现这样的异常时，总是由虚拟机接管。比如：我们从来没有人去处理过NullPointerException异常，它就是运行时异常，并且这种异常还是最常见的异常之一。<br>出现运行时异常后，如果没有捕获处理这个异常（即没有catch），系统会把异常一直往上层抛，一直到最上层，如果是多线程就由Thread.run()抛出，如果是单线程就被main()抛出。抛出之后，如果是线程，这个线程也就退出了。如果是主程序抛出的异常，那么这整个程序也就退出了。运行时异常是Exception的子类，也有一般异常的特点，是可以被catch块处理的。只不过往往我们不对他处理罢了。也就是说，你如果不对运行时异常进行处理，那么出现运行时异常之后，要么是线程中止，要么是主程序终止。<br>如果不想终止，则必须捕获所有的运行时异常，决不让这个处理线程退出。队列里面出现异常数据了，正常的处理应该是把异常数据舍弃，然后记录日志。不应该由于异常数据而影响下面对正常数据的处理。</p><p>(2)非运行时异常是RuntimeException以外的异常，类型上都属于Exception类及其子类。如IOException、SQLException等以及用户自定义的Exception异常。对于这种异常，JAVA编译器强制要求我们必需对出现的这些异常进行catch并处理，否则程序就不能编译通过。所以，面对这种异常不管我们是否愿意，只能自己去写一大堆catch块去处理可能的异常。</p><h1 id="6-finally关键字"><a href="#6-finally关键字" class="headerlink" title="6.finally关键字"></a>6.finally关键字</h1><p>来看看下面这个test1()方法：</p><pre><code>public int test1() {          try {              return 1;          } finally {              return 2;          }      }</code></pre><p>方法test1将返回2；</p><p>怎么解释呢？再来看看下面这个test2()方法：</p><pre><code>public int test2() {          int i = 1;          try {              System.out.println(&quot;try语句块中&quot;);              return 1;          } finally {              System.out.println(&quot;finally语句块中&quot;);              return 2;          }      }  </code></pre><p>运行结果是：</p><pre><code>try语句块中finally语句块中2</code></pre><p>从运行结果中可以发现，try中的return语句调用的函数先于finally中调用的函数执行，也就是说return语句先执行，finally语句后执行，所以，返回的结果是2。return并不是让函数马上返回，而是return语句执行后，将把返回结果放置进函数栈中，此时函数并不是马上返回，它要执行finally语句后才真正开始返回。</p><h1 id="常见RuntimeException："><a href="#常见RuntimeException：" class="headerlink" title="常见RuntimeException："></a>常见RuntimeException：</h1><pre><code>ArrayStoreException                试图将错误类型的对象存储到一个对象数组时抛出的异常ClassCastException                试图将对象强制转换为不是实例的子类时，抛出该异常IllegalArgumentException         抛出的异常表明向方法传递了一个不合法或不正确的参数IndexOutOfBoundsException   指示某排序索引（例如对数组、字符串或向量的排序）超出范围时抛出NoSuchElementException       表明枚举中没有更多的元素NullPointerException                当应用程序试图在需要对象的地方使用 null 时，抛出该异常</code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> exception </tag>
            
            <tag> 异常 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>mybatis连接oracle执行sql语句出现ORA-00904: invalid identifier</title>
      <link href="/2017/05/07/mybatis%E8%BF%9E%E6%8E%A5oracle%E6%89%A7%E8%A1%8Csql%E8%AF%AD%E5%8F%A5%E5%87%BA%E7%8E%B0ORA-00904-invalid-identifier/"/>
      <url>/2017/05/07/mybatis%E8%BF%9E%E6%8E%A5oracle%E6%89%A7%E8%A1%8Csql%E8%AF%AD%E5%8F%A5%E5%87%BA%E7%8E%B0ORA-00904-invalid-identifier/</url>
      
        <content type="html"><![CDATA[<h1 id="一、总结"><a href="#一、总结" class="headerlink" title="一、总结"></a>一、总结</h1><p>使用mybatis连接oracle数据库进行查询，最好确保<strong>表命全大写</strong>，否者会出现ORA-00904: invalid identifier的问题</p><p>注：本人使用的mybatis版本是3.0.5</p><h1 id="二、问题描述："><a href="#二、问题描述：" class="headerlink" title="二、问题描述："></a>二、问题描述：</h1><p> 我使用ibator工具产生的代码，有一个Dao的测试类，但是一执行就出现了ORA-00904: invalid identifier，如图：<br><img src="https://raw.githubusercontent.com/tokerr/markdownImage/master/mybatis%E8%BF%9E%E6%8E%A5oracle%E6%89%A7%E8%A1%8Csql%E8%AF%AD%E5%8F%A5%E5%87%BA%E7%8E%B0ORA-00904-invalid-identifier/Image1.png" alt=""><br> <a id="more"></a><br>原因分析，大部分情况下是由于引用了不存在的列名导致的。 解决的办法就是检查自己引用的列名称是否一致。对于某些工具生成的sql，可能导致列名称和期望不符的情况，比如，有些工具生成的列名称会带双引号，从而导致此错误。</p><p>经过查询和本人的实践验证，oracle执行查询时（这里以11g为例），对于特殊的字段命名有着非常严格的语法要求，如果是字段名称按照单词首字母大写的规范进行命名，在进行条件查询的时候必须，字段名称必须与原来命名一样并且要加上双引号，否则会包ORA-00904: invalid identifier。以下是本案例的测试截图：</p><p>表结构：<br><img src="https://raw.githubusercontent.com/tokerr/markdownImage/master/mybatis%E8%BF%9E%E6%8E%A5oracle%E6%89%A7%E8%A1%8Csql%E8%AF%AD%E5%8F%A5%E5%87%BA%E7%8E%B0ORA-00904-invalid-identifier/Image2.png" alt=""></p><p>执行查询：<br><img src="https://raw.githubusercontent.com/tokerr/markdownImage/master/mybatis%E8%BF%9E%E6%8E%A5oracle%E6%89%A7%E8%A1%8Csql%E8%AF%AD%E5%8F%A5%E5%87%BA%E7%8E%B0ORA-00904-invalid-identifier/Image3.png" alt=""></p><p>从执行的结果可以知道，最终oracle在执行sql语句的时候把条件查询的字段名转成了全大写，遇到表中没有找到相关的字段(区分大小写)，就出现了此错误。查询指定字段的值也是如此：</p><p>表结构：<br><img src="https://raw.githubusercontent.com/tokerr/markdownImage/master/mybatis%E8%BF%9E%E6%8E%A5oracle%E6%89%A7%E8%A1%8Csql%E8%AF%AD%E5%8F%A5%E5%87%BA%E7%8E%B0ORA-00904-invalid-identifier/Image4.png" alt=""></p><p>执行查询：<br><img src="https://raw.githubusercontent.com/tokerr/markdownImage/master/mybatis%E8%BF%9E%E6%8E%A5oracle%E6%89%A7%E8%A1%8Csql%E8%AF%AD%E5%8F%A5%E5%87%BA%E7%8E%B0ORA-00904-invalid-identifier/Image5.png" alt=""></p><p><img src="https://raw.githubusercontent.com/tokerr/markdownImage/master/mybatis%E8%BF%9E%E6%8E%A5oracle%E6%89%A7%E8%A1%8Csql%E8%AF%AD%E5%8F%A5%E5%87%BA%E7%8E%B0ORA-00904-invalid-identifier/Image6.png" alt=""></p><p><img src="https://raw.githubusercontent.com/tokerr/markdownImage/master/mybatis%E8%BF%9E%E6%8E%A5oracle%E6%89%A7%E8%A1%8Csql%E8%AF%AD%E5%8F%A5%E5%87%BA%E7%8E%B0ORA-00904-invalid-identifier/Image7.png" alt=""></p><h1 id="三、解决办法"><a href="#三、解决办法" class="headerlink" title="三、解决办法"></a>三、解决办法</h1><h2 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h2><p> 3.1oracle在执行sql语句进行查询的时候，默认的情况下(查询的时候不给字段加双引号)，会将字段名称转换成全大写之后再到表中进行匹配查询，比如：执行select <em> from dept where id=1，则实际执行的是:select </em> from DEPT where ID=1，这里表名和字段名全部都会转成全大写去匹配查询，一旦匹配不到(真正匹配字段名和名的时候区分大小写)，则会报错误。</p><p> 3.2如果设计表的时候不想表名和字段名都全大写，则在进行查询的时候需要在表名或者字段名称加上双引号(相当于告知oracle不要对sql语句中指定的表名或者字段名转成全大写)，并且区分大小写，这样执行查询才不会发生错误。</p><p>##解决方法##<br>因此解决的办法就是，在给字段名称进行命名的时候，建议全大写，对于表名也是全大写命名，这样不管是进行条件查询还是查询指定字段的名称的时候，都不需要严格区分大小写了并且还要加上双引号了，Oracle会自动帮你先转成全大写之后再进行匹配查询。</p>]]></content>
      
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> mybatis </tag>
            
            <tag> oracle </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>使用ibator无法根据oracle数据库中的表结构产生代码[解决方法]</title>
      <link href="/2017/05/06/%E5%85%B3%E4%BA%8E%E4%BD%BF%E7%94%A8ibator%E5%B7%A5%E5%85%B7%E8%BF%9E%E6%8E%A5oracle%E6%95%B0%E6%8D%AE%E5%BA%93%E7%94%9F%E6%88%90%E4%BB%A3%E7%A0%81%E7%9A%84%E4%BD%BF%E7%94%A8%E9%97%AE%E9%A2%98/"/>
      <url>/2017/05/06/%E5%85%B3%E4%BA%8E%E4%BD%BF%E7%94%A8ibator%E5%B7%A5%E5%85%B7%E8%BF%9E%E6%8E%A5oracle%E6%95%B0%E6%8D%AE%E5%BA%93%E7%94%9F%E6%88%90%E4%BB%A3%E7%A0%81%E7%9A%84%E4%BD%BF%E7%94%A8%E9%97%AE%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<h1 id="一、总结"><a href="#一、总结" class="headerlink" title="一、总结"></a>一、总结</h1><p><strong>使用ibator根据oracle中的表结构生成代码时，一定要确保每张表的表命全大写，否则生成失败</strong>     </p><h1 id="二、问题描述"><a href="#二、问题描述" class="headerlink" title="二、问题描述"></a>二、问题描述</h1><p>想说的已经在上面描述出来了。下面描述问题的由来已经解决的过程：</p><p>就是下面这个工具，我已经集成到了Myeclipse当中<br><a id="more"></a><br><img src="https://raw.githubusercontent.com/tokerr/markdownImage/master/%E5%85%B3%E4%BA%8E%E4%BD%BF%E7%94%A8ibator%E5%B7%A5%E5%85%B7%E8%BF%9E%E6%8E%A5oracle%E6%95%B0%E6%8D%AE%E5%BA%93%E7%94%9F%E6%88%90%E4%BB%A3%E7%A0%81%E7%9A%84%E4%BD%BF%E7%94%A8%E9%97%AE%E9%A2%98/Image1.png" alt=""></p><p>以前开始使用的都是mysql数据库，表的名称都是按照首字母大写的规范进行设计，这次的毕业设计项目使用到的是oracle，因为设计表的时候表明也是按照每个单词的首字母大写进行命名的，但是没想到，在使用ibator代码生成器生成pojo 的时候，居然失败的，而且这个问题一直困扰了我一个多月，并且百度谷歌搜索都无果，让我百思不得其解。直到今天在做毕业设计的时候，终于让我把这个问题解决了。</p><p>万幸在于，让我发现突破这个问题的关键只所在，在某一次使用这个工具对oracle中的某一张表进行操作的时候成功了(这是在本地真机上的oracle)。之前我把oracle服务器安装在电脑的虚拟机，装的是oracle10g，在使用ibator就出现了这个问题，一直怀疑是可能是因为远程的问题，或者oracle是10G不是oracle11g的版本问题，我就在真机上面装了个oracle11g的数据库，测试的时候自己阴差阳错，建表的sql语句是网上复制过来了，并且表明刚好是全大写，因此那一次就测试成功了。但今天在真机的数据库建表，表名按照单词的首字母大写命名，因此又出现了这个问题。但幸好，经过一番测试对比，终于发现原因之所在，可以说是ibator这个工具的bug吧。</p><p>另外，个人惰性思维一发作，真的是可以让人变傻。只通过自己的怀疑推测，而没有经过实践的检验，就下定结论，这是我在这个问题上思维懒惰的一个很好体现，自己下定论千万不要去推测去瞎猜，一定是要在经过实际的检验之后。另一方面是要多思考，出现这个问题的时候我就是怀疑，是因为远程的原因 或者是因为oracle版本的原因，思维懒惰的结果就是我把自己的猜测当成了自己的结论，并以此去指导自己的行为(觉得自己好悲催，问题很严重)，而从没有进一步想过，之前公司的项目也是远程的Mysql数据库使用ibator生成代码的，使用没有问题，这样就可以排除是因为远程的问题导致ibator不可以用了呀；还有怀疑是因为数据库版本的问题，竟然数据库已经成功安装，可以整成使用，跟版本有多大的联系吗？这点就不能排除了，呵呵。</p><p><strong>总之，在使用ibator获取oracle中的表结果生成代码时，一定要确保表名全大写；字段名称的命名的话，经过我的测验，字段名称全大写或者按照单词首字母大写的方式命名也是没有问题的，最终生成的pojo属性名都是全小写。</strong></p><p>三、关于ibator集成到myeclipse<br><img src="https://raw.githubusercontent.com/tokerr/markdownImage/master/%E5%85%B3%E4%BA%8E%E4%BD%BF%E7%94%A8ibator%E5%B7%A5%E5%85%B7%E8%BF%9E%E6%8E%A5oracle%E6%95%B0%E6%8D%AE%E5%BA%93%E7%94%9F%E6%88%90%E4%BB%A3%E7%A0%81%E7%9A%84%E4%BD%BF%E7%94%A8%E9%97%AE%E9%A2%98/Image2.png" alt=""><br>直接把截图上面的两个文件扔到myeclipse安装目录下的dropins文件夹就可以了，这里提供文件的连接，我都已经打包到一起了，解压即可。<a href="https://github.com/tokerr/markdownImage/raw/master/%E5%85%B3%E4%BA%8E%E4%BD%BF%E7%94%A8ibator%E5%B7%A5%E5%85%B7%E8%BF%9E%E6%8E%A5oracle%E6%95%B0%E6%8D%AE%E5%BA%93%E7%94%9F%E6%88%90%E4%BB%A3%E7%A0%81%E7%9A%84%E4%BD%BF%E7%94%A8%E9%97%AE%E9%A2%98/ibator_3.0.6.full.zip" target="_blank" rel="external">点我下载</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> mybatis </tag>
            
            <tag> oracle </tag>
            
            <tag> ibator </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>ORA-12541:TNS:无监听程序</title>
      <link href="/2017/05/06/ORA-12541-TNS-%E6%97%A0%E7%9B%91%E5%90%AC%E7%A8%8B%E5%BA%8F/"/>
      <url>/2017/05/06/ORA-12541-TNS-%E6%97%A0%E7%9B%91%E5%90%AC%E7%A8%8B%E5%BA%8F/</url>
      
        <content type="html"><![CDATA[<h2 id="一、问题描述"><a href="#一、问题描述" class="headerlink" title="一、问题描述"></a>一、问题描述</h2><p>这两天在做毕业设计，项目用到的是oracle数据库，由于之前用的都是mysql，oracle数据库的应用比较少。于是莫名奇妙的出现了个‘ORA-12514: TNS: 监听程序当前无法识别连接描述符中请求的服务’，也是折腾了两天，无果，今天接着是‘ORA-12541:TNS:无监听程序’，在windows系统的cmd上不使用实例名连接倒是可以登录，但是无法进行正常的查询操作。今天按照网上某篇博客的教程，居然把这个问题解决了，关键的一步是 启动tnslsnr，然后问题就解决了。</p><p>其实在今天电脑开始之后，我直接把360安全卫士关闭了，不排除oracle在开机 的时候某些服务被360拦截关闭的情况。</p><h2 id="二、附上cmd的操作日志"><a href="#二、附上cmd的操作日志" class="headerlink" title="二、附上cmd的操作日志"></a>二、附上cmd的操作日志</h2><pre><code>C:\Users\Administrator&gt;sqlplus / as sysdba</code></pre><a id="more"></a>    <pre><code>SQL*Plus: Release 11.2.0.1.0 Production on 星期六 5月 6 09:23:15 2017Copyright (c) 1982, 2010, Oracle.  All rights reserved.连接到:Oracle Database 11g Enterprise Edition Release 11.2.0.1.0 - 64bit ProductionWith the Partitioning, OLAP, Data Mining and Real Application Testing optionsSQL&gt; conn tokerr/tokerr已连接。SQL&gt;SQL&gt; select table_name from user_tables;TABLE_NAME------------------------------------------------------------TESTTABLE1TESTTABLE2TESTTABLE3TESTTABLE4TESTTABLE5SQL&gt; select * form TESTTABLE1;select * form TESTTABLE1         *第 1 行出现错误:ORA-00923: 未找到要求的 FROM 关键字SQL&gt; select * fROM TESTTABLE1;未选定行SQL&gt; select * fROM TESTTABLE2;未选定行SQL&gt; select * fROM TESTTABLE3;未选定行SQL&gt; exit从 Oracle Database 11g Enterprise Edition Release 11.2.0.1.0 - 64bit ProductionWith the Partitioning, OLAP, Data Mining and Real Application Testing options 断开C:\Users\Administrator&gt;sqlplus tokerr/tokerr@orclSQL*Plus: Release 11.2.0.1.0 Production on 星期六 5月 6 09:27:17 2017Copyright (c) 1982, 2010, Oracle.  All rights reserved.ERROR:ORA-12541: TNS: 无监听程序请输入用户名:C:\Users\Administrator&gt;C:\Users\Administrator&gt;sqlplus / as sysdbaSQL*Plus: Release 11.2.0.1.0 Production on 星期六 5月 6 09:37:26 2017Copyright (c) 1982, 2010, Oracle.  All rights reserved.连接到:Oracle Database 11g Enterprise Edition Release 11.2.0.1.0 - 64bit ProductionWith the Partitioning, OLAP, Data Mining and Real Application Testing optionsSQL&gt; startupORA-01081: 无法启动已在运行的 ORACLE - 请首先关闭它SQL&gt; 从 Oracle Database 11g Enterprise Edition Release 11.2.0.1.0 - 64bit ProductionWith the Partitioning, OLAP, Data Mining and Real Application Testing options 断开C:\Users\Administrator&gt;lsnrctl statusLSNRCTL for 64-bit Windows: Version 11.2.0.1.0 - Production on 06-5月 -2017 09:39:09Copyright (c) 1991, 2010, Oracle.  All rights reserved.正在连接到 (DESCRIPTION=(ADDRESS=(PROTOCOL=IPC)(KEY=EXTPROC1521)))TNS-12541: TNS: 无监听程序 TNS-12560: TNS: 协议适配器错误  TNS-00511: 无监听程序   64-bit Windows Error: 2: No such file or directory正在连接到 (DESCRIPTION=(ADDRESS=(PROTOCOL=TCP)(HOST=localhost)(PORT=1521)))TNS-12541: TNS: 无监听程序 TNS-12560: TNS: 协议适配器错误  TNS-00511: 无监听程序   64-bit Windows Error: 61: Unknown errorC:\Users\Administrator&gt;lsnrctl startLSNRCTL for 64-bit Windows: Version 11.2.0.1.0 - Production on 06-5月 -2017 09:39:40Copyright (c) 1991, 2010, Oracle.  All rights reserved.启动tnslsnr: 请稍候...TNSLSNR for 64-bit Windows: Version 11.2.0.1.0 - Production系统参数文件为F:\Ora10InstantClient\listener.ora写入f:\oracledb\diag\tnslsnr\PC-20160512QTJL\listener\alert\log.xml的日志信息监听: (DESCRIPTION=(ADDRESS=(PROTOCOL=ipc)(PIPENAME=\\.\pipe\EXTPROC1521ipc)))监听: (DESCRIPTION=(ADDRESS=(PROTOCOL=tcp)(HOST=127.0.0.1)(PORT=1521)))正在连接到 (DESCRIPTION=(ADDRESS=(PROTOCOL=IPC)(KEY=EXTPROC1521)))LISTENER 的 STATUS------------------------别名                      LISTENER版本                      TNSLSNR for 64-bit Windows: Version 11.2.0.1.0 - Production启动日期                  06-5月 -2017 09:39:46正常运行时间              0 天 0 小时 0 分 8 秒跟踪级别                  off安全性                    ON: Local OS AuthenticationSNMP                      OFF监听程序参数文件          F:\Ora10InstantClient\listener.ora监听程序日志文件          f:\oracledb\diag\tnslsnr\PC-20160512QTJL\listener\alert\log.xml监听端点概要...  (DESCRIPTION=(ADDRESS=(PROTOCOL=ipc)(PIPENAME=\\.\pipe\EXTPROC1521ipc)))  (DESCRIPTION=(ADDRESS=(PROTOCOL=tcp)(HOST=127.0.0.1)(PORT=1521)))服务摘要..服务 &quot;CLRExtProc&quot; 包含 1 个实例。  实例 &quot;CLRExtProc&quot;, 状态 UNKNOWN, 包含此服务的 1 个处理程序...服务 &quot;orcl&quot; 包含 1 个实例。  实例 &quot;orcl&quot;, 状态 UNKNOWN, 包含此服务的 1 个处理程序...命令执行成功C:\Users\Administrator&gt;lsnrctl statusLSNRCTL for 64-bit Windows: Version 11.2.0.1.0 - Production on 06-5月 -2017 09:41:30Copyright (c) 1991, 2010, Oracle.  All rights reserved.正在连接到 (DESCRIPTION=(ADDRESS=(PROTOCOL=IPC)(KEY=EXTPROC1521)))LISTENER 的 STATUS------------------------别名                      LISTENER版本                      TNSLSNR for 64-bit Windows: Version 11.2.0.1.0 - Production启动日期                  06-5月 -2017 09:39:46正常运行时间              0 天 0 小时 1 分 48 秒跟踪级别                  off安全性                    ON: Local OS AuthenticationSNMP                      OFF监听程序参数文件          F:\Ora10InstantClient\listener.ora监听程序日志文件          f:\oracledb\diag\tnslsnr\PC-20160512QTJL\listener\alert\log.xml监听端点概要...  (DESCRIPTION=(ADDRESS=(PROTOCOL=ipc)(PIPENAME=\\.\pipe\EXTPROC1521ipc)))  (DESCRIPTION=(ADDRESS=(PROTOCOL=tcp)(HOST=127.0.0.1)(PORT=1521)))服务摘要..服务 &quot;CLRExtProc&quot; 包含 1 个实例。  实例 &quot;CLRExtProc&quot;, 状态 UNKNOWN, 包含此服务的 1 个处理程序...服务 &quot;orcl&quot; 包含 1 个实例。  实例 &quot;orcl&quot;, 状态 UNKNOWN, 包含此服务的 1 个处理程序...命令执行成功C:\Users\Administrator&gt;sqlplus tokerr/tokerr@orclSQL*Plus: Release 11.2.0.1.0 Production on 星期六 5月 6 09:41:36 2017Copyright (c) 1982, 2010, Oracle.  All rights reserved.连接到:Oracle Database 11g Enterprise Edition Release 11.2.0.1.0 - 64bit ProductionWith the Partitioning, OLAP, Data Mining and Real Application Testing optionsSQL&gt; select * from TESTTABLES;select * from TESTTABLES              *第 1 行出现错误:ORA-00942: 表或视图不存在SQL&gt; select * from TESTTABLE1;未选定行SQL&gt;</code></pre><h2 id="三、正文"><a href="#三、正文" class="headerlink" title="三、正文"></a>三、正文</h2><p>在用PL/SQL Developer连接数据库时出现<br>“ORA-12541:TNS:无监听程序”错误。</p><h3 id="1、检查listener-log日志"><a href="#1、检查listener-log日志" class="headerlink" title="1、检查listener.log日志"></a>1、检查listener.log日志</h3><p>发现下面错误：</p><pre><code>TNSLSNR for 32-bit Windows: Version 10.2.0.1.0 - Production on 20-9月 -2008 10:25:26Copyright (c) 1991, 2005, Oracle. All rights reserved.系统参数文件为D:/oracle/product/10.2.0/db_1/network/admin/listener.ora写入D:/oracle/product/10.2.0/db_1/network/log/listener.log的日志信息写入D:/oracle/product/10.2.0/db_1/network/trace/listener.trc的跟踪信息跟踪级别当前为0以 pid=1704 开始监听: (DESCRIPTION=(ADDRESS=(PROTOCOL=ipc)(PIPENAME=//./pipe/EXTPROC1ipc)))监听该对象时出错: (DESCRIPTION=(ADDRESS=(PROTOCOL=TCP)(HOST=0.5.0.5)(PORT=1521)))TNS-12545: 因目标主机或对象不存在, 连接失败TNS-12560: TNS: 协议适配器错误TNS-00515: 因目标主机或对象不存在, 连接失败32-bit Windows Error: 49: Unknown error不再监听: (DESCRIPTION=(ADDRESS=(PROTOCOL=ipc)(PIPENAME=//./pipe/EXTPROC1ipc)))</code></pre><h3 id="2、查看Oracle的listener是否启动"><a href="#2、查看Oracle的listener是否启动" class="headerlink" title="2、查看Oracle的listener是否启动"></a>2、查看Oracle的listener是否启动</h3><pre><code>C:/Documents and Settings/mengzhaoliang&gt;lsnrctl statusLSNRCTL for 32-bit Windows: Version 10.2.0.1.0 - Production on 20-9月 -2008 10:50:44Copyright (c) 1991, 2005, Oracle. All rights reserved.正在连接到 (DESCRIPTION=(ADDRESS=(PROTOCOL=IPC)(KEY=EXTPROC1)))TNS-12541: TNS: 无监听程序TNS-12560: TNS: 协议适配器错误TNS-00511: 无监听程序32-bit Windows Error: 2: No such file or directory正在连接到 (DESCRIPTION=(ADDRESS=(PROTOCOL=TCP)(HOST=0.5.0.5)(PORT=1521)))TNS-12535: TNS: 操作超时TNS-12560: TNS: 协议适配器错误TNS-00505: 操作超时32-bit Windows Error: 60: Unknown error</code></pre><p>原来没有启动listener，用“lsnrctl start”命令也不能启动。</p><pre><code>C:/Documents and Settings/mengzhaoliang&gt;lsnrctl startLSNRCTL for 32-bit Windows: Version 10.2.0.1.0 - Production on 20-9月 -2008 10:52:16Copyright (c) 1991, 2005, Oracle. All rights reserved.启动tnslsnr: 请稍候...TNSLSNR for 32-bit Windows: Version 10.2.0.1.0 - Production系统参数文件为D:/oracle/product/10.2.0/db_1/network/admin/listener.ora写入D:/oracle/product/10.2.0/db_1/network/log/listener.log的日志信息监听: (DESCRIPTION=(ADDRESS=(PROTOCOL=ipc)(PIPENAME=//./pipe/EXTPROC1ipc)))监听该对象时出错: (DESCRIPTION=(ADDRESS=(PROTOCOL=TCP)(HOST=0.5.0.5)(PORT=1521)))TNS-12545: 因目标主机或对象不存在, 连接失败TNS-12560: TNS: 协议适配器错误TNS-00515: 因目标主机或对象不存在, 连接失败32-bit Windows Error: 49: Unknown error</code></pre><p>监听程序未能启动。请参阅上面的错误消息…</p><h3 id="3、查看listener-ora的内容："><a href="#3、查看listener-ora的内容：" class="headerlink" title="3、查看listener.ora的内容："></a>3、查看listener.ora的内容：</h3><pre><code># listener.ora Network Configuration File: D:/oracle/product/10.2.0/db_1/network/admin/listener.ora# Generated by Oracle configuration tools.SID_LIST_LISTENER =(SID_LIST =(SID_DESC =(SID_NAME = PLSExtProc)(ORACLE_HOME = D:/oracle/product/10.2.0/db_1)(PROGRAM = extproc)))LISTENER =(DESCRIPTION_LIST =(DESCRIPTION =(ADDRESS = (PROTOCOL = IPC)(KEY = EXTPROC1))(ADDRESS = (PROTOCOL = TCP)(HOST = 0.5.0.5)(PORT = 1521))))</code></pre><p>原来本机的ip发生改变后，就出现了上述问题，改变数据库的监听ip地址:<br>把<code>(ADDRESS = (PROTOCOL = TCP)(HOST = 0.5.0.5)(PORT = 1521))</code><br>改成<code>(ADDRESS = (PROTOCOL = TCP)(HOST = 127.0.0.1)(PORT = 1521))</code><br>127.0.0.1：也就是目前数据库正在用的ip地址。</p><h3 id="4、再次启动oracle的listener"><a href="#4、再次启动oracle的listener" class="headerlink" title="4、再次启动oracle的listener"></a>4、再次启动oracle的listener</h3><pre><code>C:/Documents and Settings/mengzhaoliang&gt;lsnrctl startLSNRCTL for 32-bit Windows: Version 10.2.0.1.0 - Production on 20-9月 -2008 10:54:40Copyright (c) 1991, 2005, Oracle. All rights reserved.启动tnslsnr: 请稍候...TNSLSNR for 32-bit Windows: Version 10.2.0.1.0 - Production系统参数文件为D:/oracle/product/10.2.0/db_1/network/admin/listener.ora写入D:/oracle/product/10.2.0/db_1/network/log/listener.log的日志信息监听: (DESCRIPTION=(ADDRESS=(PROTOCOL=ipc)(PIPENAME=//./pipe/EXTPROC1ipc)))监听: (DESCRIPTION=(ADDRESS=(PROTOCOL=tcp)(HOST=127.0.0.1)(PORT=1521)))正在连接到 (DESCRIPTION=(ADDRESS=(PROTOCOL=IPC)(KEY=EXTPROC1)))LISTENER 的 STATUS------------------------别名                      LISTENER版本                      TNSLSNR for 32-bit Windows: Version 10.2.0.1.0 - Production启动日期                  20-9月 -2008 10:54:41正常运行时间              0 天 0 小时 0 分 1 秒跟踪级别                  off安全性                    ON: Local OS AuthenticationSNMP                      OFF监听程序参数文件          D:/oracle/product/10.2.0/db_1/network/admin/listener.ora监听程序日志文件          D:/oracle/product/10.2.0/db_1/network/log/listener.log监听端点概要...(DESCRIPTION=(ADDRESS=(PROTOCOL=ipc)(PIPENAME=//./pipe/EXTPROC1ipc)))(DESCRIPTION=(ADDRESS=(PROTOCOL=tcp)(HOST=127.0.0.1)(PORT=1521)))服务摘要..服务 &quot;PLSExtProc&quot; 包含 1 个例程。例程 &quot;PLSExtProc&quot;, 状态 UNKNOWN, 包含此服务的 1 个处理程序...</code></pre><p>命令执行成功</p><p>启动已经成功，</p><h3 id="5-再tnsnames-ora上添加上"><a href="#5-再tnsnames-ora上添加上" class="headerlink" title="5.再tnsnames.ora上添加上"></a>5.再tnsnames.ora上添加上</h3><pre><code>ORCL_127.0.0.1 =(DESCRIPTION =(ADDRESS = (PROTOCOL = TCP)(HOST = 127.0.0.1)(PORT = 1521))(CONNECT_DATA =(SERVER = DEDICATED)(SERVICE_NAME = orcl)))</code></pre><p>6、再次用PL/SQL Developer再次连接数据库<br>出现下面错误：<br><strong>TNS-12514: TNS: 监听程序当前无法识别连接描述符中请求的服务</strong><br>再次检查listener.log日志</p><pre><code>20-9月 -2008 11:01:54 * (CONNECT_DATA=(SERVER=DEDICATED)(SERVICE_NAME=orcl)(CID=(PROGRAM=D:/plsql/plsqldev.exe)(HOST=RUIFEI-EF0ADC98)(USER=mengzhaoliang))) * (ADDRESS=(PROTOCOL=tcp)(HOST=127.0.0.1)(PORT=1267)) * establish * orcl * 12514TNS-12514: TNS: 监听程序当前无法识别连接描述符中请求的服务查看listener：C:/Documents and Settings/mengzhaoliang&gt;lsnrctl servicesLSNRCTL for 32-bit Windows: Version 10.2.0.1.0 - Production on 20-9月 -2008 11:11:09Copyright (c) 1991, 2005, Oracle. All rights reserved.正在连接到 (DESCRIPTION=(ADDRESS=(PROTOCOL=IPC)(KEY=EXTPROC1)))服务摘要..服务 &quot;PLSExtProc&quot; 包含 1 个例程。例程 &quot;PLSExtProc&quot;, 状态 UNKNOWN, 包含此服务的 1 个处理程序...处理程序:&quot;DEDICATED&quot; 已建立:0 已被拒绝:0LOCAL SERVER</code></pre><p>命令执行成功</p><h3 id="7、用sqlplus也出现同样错误："><a href="#7、用sqlplus也出现同样错误：" class="headerlink" title="7、用sqlplus也出现同样错误："></a>7、用sqlplus也出现同样错误：</h3><pre><code>C:/Documents and Settings/mengzhaoliang&gt;sqlplusscott/mzl@ORCL_127.0.0.1SQL*Plus: Release 10.2.0.1.0 - Production on 星期六 9月 20 11:15:09 2008Copyright (c) 1982, 2005, Oracle. All rights reserved.ERROR:ORA-12514: TNS: 监听程序当前无法识别连接描述符中请求的服务</code></pre><h3 id="8、查看listenser状态："><a href="#8、查看listenser状态：" class="headerlink" title="8、查看listenser状态："></a>8、查看listenser状态：</h3><pre><code>C:/Documents and Settings/mengzhaoliang&gt;lsnrctl statusLSNRCTL for 32-bit Windows: Version 10.2.0.1.0 - Production on 20-9月 -2008 11:26:42Copyright (c) 1991, 2005, Oracle. All rights reserved.正在连接到 (DESCRIPTION=(ADDRESS=(PROTOCOL=IPC)(KEY=EXTPROC1)))LISTENER 的 STATUS------------------------别名                      LISTENER版本                      TNSLSNR for 32-bit Windows: Version 10.2.0.1.0 - Production启动日期                  20-9月 -2008 11:24:33正常运行时间              0 天 0 小时 2 分 8 秒跟踪级别                  off安全性                    ON: Local OS AuthenticationSNMP                      OFF监听程序参数文件          D:/oracle/product/10.2.0/db_1/network/admin/listener.ora监听程序日志文件          D:/oracle/product/10.2.0/db_1/network/log/listener.log监听端点概要...(DESCRIPTION=(ADDRESS=(PROTOCOL=ipc)(PIPENAME=//./pipe/EXTPROC1ipc)))(DESCRIPTION=(ADDRESS=(PROTOCOL=tcp)(HOST=127.0.0.1)(PORT=1521)))服务摘要..服务 &quot;PLSExtProc&quot; 包含 1 个例程。例程 &quot;PLSExtProc&quot;, 状态 UNKNOWN, 包含此服务的 1 个处理程序...</code></pre><p>命令执行成功</p><pre><code>C:/Documents and Settings/mengzhaoliang&gt;tnsping orclTNS Ping Utility for 32-bit Windows: Version 10.2.0.1.0 - Production on 20-9月 -2008 11:27:43Copyright (c) 1997, 2005, Oracle. All rights reserved.已使用的参数文件:D:/oracle/product/10.2.0/db_1/network/admin/sqlnet.oraTNS-03505: 无法解析名称</code></pre><h3 id="9、查看sqlnet-ora内容："><a href="#9、查看sqlnet-ora内容：" class="headerlink" title="9、查看sqlnet.ora内容："></a>9、查看sqlnet.ora内容：</h3><pre><code># sqlnet.ora Network Configuration File: D:/oracle/product/10.2.0/db_1/network/admin/sqlnet.ora# Generated by Oracle configuration tools.# This file is actually generated by netca. But if customers choose to# install &quot;Software Only&quot;, this file wont exist and without the native# authentication, they will not be able to connect to the database on NT.SQLNET.AUTHENTICATION_SERVICES= (NTS)NAMES.DIRECTORY_PATH= (TNSNAMES, EZCONNECT)</code></pre><p>10.把listener.ora的内容：</p><pre><code># listener.ora Network Configuration File: D:/oracle/product/10.2.0/db_1/network/admin/listener.ora# Generated by Oracle configuration tools.SID_LIST_LISTENER =(SID_LIST =(SID_DESC =      (SID_NAME = PLSExtProc)(ORACLE_HOME = D:/oracle/product/10.2.0/db_1)      (PROGRAM = extproc)))LISTENER =(DESCRIPTION_LIST =(DESCRIPTION =(ADDRESS = (PROTOCOL = IPC)(KEY = EXTPROC1))(ADDRESS = (PROTOCOL = TCP)(HOST = 127.0.0.1)(PORT = 1521))))改成下面的内容：# listener.ora Network Configuration File: D:/oracle/product/10.2.0/db_1/network/admin/listener.ora# Generated by Oracle configuration tools.SID_LIST_LISTENER =(SID_LIST =(SID_DESC =      (SID_NAME = orcl)(ORACLE_HOME = D:/oracle/product/10.2.0/db_1)#      (PROGRAM = extproc)))LISTENER =(DESCRIPTION_LIST =(DESCRIPTION =(ADDRESS = (PROTOCOL = IPC)(KEY = orcl))(ADDRESS = (PROTOCOL = TCP)(HOST = 127.0.0.1)(PORT = 1521))))</code></pre><h3 id="11、然后关闭、再启动listener"><a href="#11、然后关闭、再启动listener" class="headerlink" title="11、然后关闭、再启动listener"></a>11、然后关闭、再启动listener</h3><p>在cmd中执行“lsnrctl stop” 和“lsnrctl stop”命令，再次登陆正常！</p><pre><code>C:/Documents and Settings/mengzhaoliang&gt;sqlplus scott/mzl@orclSQL*Plus: Release 10.2.0.1.0 - Production on 星期六 9月 20 11:55:47 2008Copyright (c) 1982, 2005, Oracle. All rights reserved.连接到:Oracle Database 10g Enterprise Edition Release 10.2.0.1.0 - ProductionWith the Partitioning, OLAP and Data Mining optionsSQL&gt;</code></pre><p>再次用PL/SQL Peveloper登陆就没有问题了。</p><p>完毕!</p><p>我通过以上步骤我的问题还没解决，然后重启了一下<code>OracleOraDb10g_home1TNSListener</code>服务就行了</p><p><a href="http://blog.csdn.net/kobe_lzq/article/details/4846734" target="_blank" rel="external">原文链接</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> 数据库 </tag>
            
            <tag> Oracle </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>序列化和反序列化的简单理解</title>
      <link href="/2017/05/05/%E5%BA%8F%E5%88%97%E5%8C%96%E5%92%8C%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E7%9A%84%E7%AE%80%E5%8D%95%E7%90%86%E8%A7%A3/"/>
      <url>/2017/05/05/%E5%BA%8F%E5%88%97%E5%8C%96%E5%92%8C%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E7%9A%84%E7%AE%80%E5%8D%95%E7%90%86%E8%A7%A3/</url>
      
        <content type="html"><![CDATA[<h2 id="一、序列化和反序列化的概念"><a href="#一、序列化和反序列化的概念" class="headerlink" title="一、序列化和反序列化的概念"></a>一、序列化和反序列化的概念</h2><p>　<strong>把对象转换为字节序列的过程称为对象的序列化。</strong></p><p>　<strong>把字节序列恢复为对象的过程称为对象的反序列化。</strong></p><p>　　<em>对象的序列化主要有两种用途：</em></p><pre><code>1） 把对象的字节序列永久地保存到硬盘上，通常存放在一个文件中；2） 在网络上传送对象的字节序列。</code></pre><a id="more"></a><p>　　在很多应用中，需要对某些对象进行序列化，让它们离开内存空间，入住物理硬盘，以便长期保存。比如最常见的是Web服务器中的Session对象，当有 10万用户并发访问，就有可能出现10万个Session对象，内存可能吃不消，于是Web容器就会把一些seesion先序列化到硬盘中，等要用了，再把保存在硬盘中的对象还原到内存中。</p><p>　　当两个进程在进行远程通信时，彼此可以发送各种类型的数据。无论是何种类型的数据，都会以二进制序列的形式在网络上传送。发送方需要把这个Java对象转换为字节序列，才能在网络上传送；接收方则需要把字节序列再恢复为Java对象。</p><h2 id="二、JDK类库中的序列化API"><a href="#二、JDK类库中的序列化API" class="headerlink" title="二、JDK类库中的序列化API"></a>二、JDK类库中的序列化API</h2><p>　    java.io.ObjectOutputStream代表对象输出流，它的writeObject(Object obj)方法可对参数指定的obj对象进行序列化，把得到的字节序列写到一个目标输出流中。</p><p>　　java.io.ObjectInputStream代表对象输入流，它的readObject()方法从一个源输入流中读取字节序列，再把它们反序列化为一个对象，并将其返回。<br>　　只有实现了Serializable和Externalizable接口的类的对象才能被序列化。Externalizable接口继承自 Serializable接口，实现Externalizable接口的类完全由自身来控制序列化的行为，而仅实现Serializable接口的类可以 采用默认的序列化方式 。</p><p>　　<em>对象序列化包括如下步骤：</em></p><pre><code>1） 创建一个对象输出流，它可以包装一个其他类型的目标输出流，如文件输出流；2） 通过对象输出流的writeObject()方法写对象。</code></pre><p>　　<em>对象反序列化的步骤如下：</em></p><pre><code>1） 创建一个对象输入流，它可以包装一个其他类型的源输入流，如文件输入流；2） 通过对象输入流的readObject()方法读取对象。</code></pre><h3 id="对象序列化和反序列范例："><a href="#对象序列化和反序列范例：" class="headerlink" title="对象序列化和反序列范例："></a>对象序列化和反序列范例：</h3><p>　　定义一个Person类，实现Serializable接口</p><pre><code> 1 import java.io.Serializable; 2  3 /** 4  * &lt;p&gt;ClassName: Person&lt;p&gt; 5  * &lt;p&gt;Description:测试对象序列化和反序列化&lt;p&gt; 6  * @author xudp 7  * @version 1.0 V 8  * @createTime 2014-6-9 下午02:33:25 9  */10 public class Person implements Serializable {11 12     /**13      * 序列化ID14      */15     private static final long serialVersionUID = -5809782578272943999L;16     private int age;17     private String name;18     private String sex;19 20     public int getAge() {21         return age;22     }23 24     public String getName() {25         return name;26     }27 28     public String getSex() {29         return sex;30     }31 32     public void setAge(int age) {33         this.age = age;34     }35 36     public void setName(String name) {37         this.name = name;38     }39 40     public void setSex(String sex) {41         this.sex = sex;42     }43 }</code></pre><h3 id="序列化和反序列化Person类对象"><a href="#序列化和反序列化Person类对象" class="headerlink" title="序列化和反序列化Person类对象"></a>序列化和反序列化Person类对象</h3><pre><code> 1 import java.io.File; 2 import java.io.FileInputStream; 3 import java.io.FileNotFoundException; 4 import java.io.FileOutputStream; 5 import java.io.IOException; 6 import java.io.ObjectInputStream; 7 import java.io.ObjectOutputStream; 8 import java.text.MessageFormat; 9 10 /**11  * &lt;p&gt;ClassName: TestObjSerializeAndDeserialize&lt;p&gt;12  * &lt;p&gt;Description: 测试对象的序列化和反序列&lt;p&gt;13  * @author xudp14  * @version 1.0 V15  * @createTime 2014-6-9 下午03:17:2516  */17 public class TestObjSerializeAndDeserialize {18 19     public static void main(String[] args) throws Exception {20         SerializePerson();//序列化Person对象21         Person p = DeserializePerson();//反序列Perons对象22         System.out.println(MessageFormat.format(&quot;name={0},age={1},sex={2}&quot;,23                                                  p.getName(), p.getAge(), p.getSex()));24     }25     26     /**27      * MethodName: SerializePerson 28      * Description: 序列化Person对象29      * @author xudp30      * @throws FileNotFoundException31      * @throws IOException32      */33     private static void SerializePerson() throws FileNotFoundException,34             IOException {35         Person person = new Person();36         person.setName(&quot;gacl&quot;);37         person.setAge(25);38         person.setSex(&quot;男&quot;);39         // ObjectOutputStream 对象输出流，将Person对象存储到E盘的Person.txt文件中，完成对Person对象的序列化操作40         ObjectOutputStream oo = new ObjectOutputStream(new FileOutputStream(41                 new File(&quot;E:/Person.txt&quot;)));42         oo.writeObject(person);43         System.out.println(&quot;Person对象序列化成功！&quot;);44         oo.close();45     }46 47     /**48      * MethodName: DeserializePerson 49      * Description: 反序列Perons对象50      * @author xudp51      * @return52      * @throws Exception53      * @throws IOException54      */55     private static Person DeserializePerson() throws Exception, IOException {56         ObjectInputStream ois = new ObjectInputStream(new FileInputStream(57                 new File(&quot;E:/Person.txt&quot;)));58         Person person = (Person) ois.readObject();59         System.out.println(&quot;Person对象反序列化成功！&quot;);60         return person;61     }62 63 }</code></pre><h3 id="代码运行结果如下："><a href="#代码运行结果如下：" class="headerlink" title="代码运行结果如下："></a>代码运行结果如下：</h3><p>序列化Person成功后在E盘生成了一个Person.txt文件，而反序列化Person是读取E盘的Person.txt后生成了一个Person对象</p><h2 id="三、serialVersionUID的作用"><a href="#三、serialVersionUID的作用" class="headerlink" title="三、serialVersionUID的作用"></a>三、serialVersionUID的作用</h2><p>　s​e​r​i​a​l​V​e​r​s​i​o​n​U​I​D​:​ ​字​面​意​思​上​是​序​列​化​的​版​本​号​，凡是实现Serializable接口的类都有一个表示序列化版本标识符的静态变量</p><p> <code>private static final long serialVersionUID</code></p><p>serialVersionUID有两种生成方式：</p><p>　　采用这种方式生成的serialVersionUID是1L，例如：</p><pre><code>1 private static final long serialVersionUID = 1L;</code></pre><p>　　采用这种方式生成的serialVersionUID是根据类名，接口名，方法和属性等来生成的，例如：</p><pre><code>1 private static final long serialVersionUID = 4603642343377807741L;</code></pre><p>   扯了那么多，那么serialVersionUID(序列化版本号)到底有什么用呢，我们用如下的例子来说明一下serialVersionUID的作用，看下面的代码：</p><pre><code> 1 import java.io.File; 2 import java.io.FileInputStream; 3 import java.io.FileNotFoundException; 4 import java.io.FileOutputStream; 5 import java.io.IOException; 6 import java.io.ObjectInputStream; 7 import java.io.ObjectOutputStream; 8 import java.io.Serializable; 9 10 public class TestSerialversionUID {11 12     public static void main(String[] args) throws Exception {13         SerializeCustomer();// 序列化Customer对象14         Customer customer = DeserializeCustomer();// 反序列Customer对象15         System.out.println(customer);16     }17 18     /**19      * MethodName: SerializeCustomer 20      * Description: 序列化Customer对象21      * @author xudp22      * @throws FileNotFoundException23      * @throws IOException24      */25     private static void SerializeCustomer() throws FileNotFoundException,26             IOException {27         Customer customer = new Customer(&quot;gacl&quot;,25);28         // ObjectOutputStream 对象输出流29         ObjectOutputStream oo = new ObjectOutputStream(new FileOutputStream(30                 new File(&quot;E:/Customer.txt&quot;)));31         oo.writeObject(customer);32         System.out.println(&quot;Customer对象序列化成功！&quot;);33         oo.close();34     }35 36     /**37      * MethodName: DeserializeCustomer 38      * Description: 反序列Customer对象39      * @author xudp40      * @return41      * @throws Exception42      * @throws IOException43      */44     private static Customer DeserializeCustomer() throws Exception, IOException {45         ObjectInputStream ois = new ObjectInputStream(new FileInputStream(46                 new File(&quot;E:/Customer.txt&quot;)));47         Customer customer = (Customer) ois.readObject();48         System.out.println(&quot;Customer对象反序列化成功！&quot;);49         return customer;50     }51 }52 53 /**54  * &lt;p&gt;ClassName: Customer&lt;p&gt;55  * &lt;p&gt;Description: Customer实现了Serializable接口，可以被序列化&lt;p&gt;56  * @author xudp57  * @version 1.0 V58  * @createTime 2014-6-9 下午04:20:1759  */60 class Customer implements Serializable {61     //Customer类中没有定义serialVersionUID62     private String name;63     private int age;64 65     public Customer(String name, int age) {66         this.name = name;67         this.age = age;68     }69 70     /*71      * @MethodName toString72      * @Description 重写Object类的toString()方法73      * @author xudp74      * @return string75      * @see java.lang.Object#toString()76      */77     @Override78     public String toString() {79         return &quot;name=&quot; + name + &quot;, age=&quot; + age;80     }81 }</code></pre><p>运行结果：</p><p>序列化和反序列化都成功了。</p><p>下面我们修改一下Customer类，添加多一个sex属性，如下：</p><pre><code> 1 class Customer implements Serializable { 2     //Customer类中没有定义serialVersionUID 3     private String name; 4     private int age; 5  6     //新添加的sex属性 7     private String sex; 8      9     public Customer(String name, int age) {10         this.name = name;11         this.age = age;12     }13     14     public Customer(String name, int age,String sex) {15         this.name = name;16         this.age = age;17         this.sex = sex;18     }19 20     /*21      * @MethodName toString22      * @Description 重写Object类的toString()方法23      * @author xudp24      * @return string25      * @see java.lang.Object#toString()26      */27     @Override28     public String toString() {29         return &quot;name=&quot; + name + &quot;, age=&quot; + age;30     }31 }</code></pre><p>然后执行反序列操作，此时就会抛出如下的异常信息：</p><pre><code>1 Exception in thread &quot;main&quot; java.io.InvalidClassException: Customer; 2 local class incompatible: 3 stream classdesc serialVersionUID = -88175599799432325, 4 local class serialVersionUID = -5182532647273106745</code></pre><p>意思就是说，文件流中的class和classpath中的class，也就是修改过后的class，不兼容了，处于安全机制考虑，程序抛出了错误，并且拒绝载入。那么如果我们真的有需求要在序列化后添加一个字段或者方法呢？应该怎么办？那就是自己去指定serialVersionUID。在TestSerialversionUID例子中，没有指定Customer类的serialVersionUID的，那么java编译器会自动给这个class进行一个摘要算法，类似于指纹算法，只要这个文件 多一个空格，得到的UID就会截然不同的，可以保证在这么多类中，这个编号是唯一的。所以，添加了一个字段后，由于没有显指定 serialVersionUID，编译器又为我们生成了一个UID，当然和前面保存在文件中的那个不会一样了，于是就出现了2个序列化版本号不一致的错误。因此，只要我们自己指定了serialVersionUID，就可以在序列化后，去添加一个字段，或者方法，而不会影响到后期的还原，还原后的对象照样可以使用，而且还多了方法或者属性可以用。</p><p>　　下面继续修改Customer类，给Customer指定一个serialVersionUID，修改后的代码如下：</p><pre><code> 1 class Customer implements Serializable { 2     /** 3      * Customer类中定义的serialVersionUID(序列化版本号) 4      */ 5     private static final long serialVersionUID = -5182532647273106745L; 6     private String name; 7     private int age; 8  9     //新添加的sex属性10     //private String sex;11     12     public Customer(String name, int age) {13         this.name = name;14         this.age = age;15     }16     17     /*public Customer(String name, int age,String sex) {18         this.name = name;19         this.age = age;20         this.sex = sex;21     }*/22 23     /*24      * @MethodName toString25      * @Description 重写Object类的toString()方法26      * @author xudp27      * @return string28      * @see java.lang.Object#toString()29      */30     @Override31     public String toString() {32         return &quot;name=&quot; + name + &quot;, age=&quot; + age;33     }34 }</code></pre><p>重新执行序列化操作，将Customer对象序列化到本地硬盘的Customer.txt文件存储，然后修改Customer类，添加sex属性，修改后的Customer类代码如下：</p><pre><code> 1 class Customer implements Serializable { 2     /** 3      * Customer类中定义的serialVersionUID(序列化版本号) 4      */ 5     private static final long serialVersionUID = -5182532647273106745L; 6     private String name; 7     private int age; 8  9     //新添加的sex属性10     private String sex;11     12     public Customer(String name, int age) {13         this.name = name;14         this.age = age;15     }16     17     public Customer(String name, int age,String sex) {18         this.name = name;19         this.age = age;20         this.sex = sex;21     }22 23     /*24      * @MethodName toString25      * @Description 重写Object类的toString()方法26      * @author xudp27      * @return string28      * @see java.lang.Object#toString()29      */30     @Override31     public String toString() {32         return &quot;name=&quot; + name + &quot;, age=&quot; + age;33     }34 }</code></pre><p>执行反序列操作，这次就可以反序列成功了，如下所示：</p><p>　　<br>四、serialVersionUID的取值<br>　　serialVersionUID的取值是Java运行时环境根据类的内部细节自动生成的。如果对类的源代码作了修改，再重新编译，新生成的类文件的serialVersionUID的取值有可能也会发生变化。<br>　　类的serialVersionUID的默认值完全依赖于Java编译器的实现，对于同一个类，用不同的Java编译器编译，有可能会导致不同的 serialVersionUID，也有可能相同。为了提高serialVersionUID的独立性和确定性，强烈建议在一个可序列化类中显示的定义serialVersionUID，为它赋予明确的值。</p><p>　　显式地定义serialVersionUID有两种用途：</p><pre><code>1、 在某些场合，希望类的不同版本对序列化兼容，因此需要确保类的不同版本具有相同的serialVersionUID；2、 在某些场合，不希望类的不同版本对序列化兼容，因此需要确保类的不同版本具有不同的serialVersionUID。</code></pre><p><a href="http://blog.csdn.net/abc6368765/article/details/51365838" target="_blank" rel="external">原文连接</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> java </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>validation实现后台校验;</title>
      <link href="/2017/05/02/hibernate-validation%E5%AE%9E%E7%8E%B0%E5%90%8E%E5%8F%B0%E6%A0%A1%E9%AA%8C/"/>
      <url>/2017/05/02/hibernate-validation%E5%AE%9E%E7%8E%B0%E5%90%8E%E5%8F%B0%E6%A0%A1%E9%AA%8C/</url>
      
        <content type="html"><![CDATA[<h3 id="1-validation校验"><a href="#1-validation校验" class="headerlink" title="1    validation校验"></a>1    validation校验</h3><p>对前端的校验大多数通过js在页面校验，这种方法比较简单，如果对安全性考虑，还要在后台校验。</p><p>springmvc使用JSR-303（javaEE6规范的一部分）校验规范，springmvc使用的是Hibernate Validator（和Hibernate的ORM）</p><h4 id="1-1-加入Hibernate-Validator的jar"><a href="#1-1-加入Hibernate-Validator的jar" class="headerlink" title="1.1    加入Hibernate Validator的jar"></a>1.1    加入Hibernate Validator的jar</h4><a id="more"></a><p><img src="https://raw.githubusercontent.com/tokerr/markdownImage/master/hibernate-validation%E6%A0%A1%E9%AA%8C/Image.png" alt=""></p><h4 id="1-2-在处理器适配器中配置校验器"><a href="#1-2-在处理器适配器中配置校验器" class="headerlink" title="1.2    在处理器适配器中配置校验器"></a>1.2    在处理器适配器中配置校验器</h4><p><img src="https://raw.githubusercontent.com/tokerr/markdownImage/master/hibernate-validation%E6%A0%A1%E9%AA%8C/Image%202.png" alt=""></p><p><img src="https://raw.githubusercontent.com/tokerr/markdownImage/master/hibernate-validation%E6%A0%A1%E9%AA%8C/Image%203.png" alt=""></p><p><img src="https://raw.githubusercontent.com/tokerr/markdownImage/master/hibernate-validation%E6%A0%A1%E9%AA%8C/Image%204.png" alt=""></p><h4 id="1-3-创建CustomValidationMessages"><a href="#1-3-创建CustomValidationMessages" class="headerlink" title="1.3    创建CustomValidationMessages"></a>1.3    创建CustomValidationMessages</h4><p>在classpath下创建CustomValidationMessages.properties</p><p><img src="https://raw.githubusercontent.com/tokerr/markdownImage/master/hibernate-validation%E6%A0%A1%E9%AA%8C/Image%205.png" alt=""></p><h4 id="1-4-校验规则"><a href="#1-4-校验规则" class="headerlink" title="1.4    校验规则"></a>1.4    校验规则</h4><p>需求：<br>商品信息提交时校验 ，商品生产日期不能为空，商品名称长度在1到30字符之间</p><p><img src="https://raw.githubusercontent.com/tokerr/markdownImage/master/hibernate-validation%E6%A0%A1%E9%AA%8C/Image%206.png" alt=""></p><h4 id="1-5-捕获错误"><a href="#1-5-捕获错误" class="headerlink" title="1.5    捕获错误"></a>1.5    捕获错误</h4><p>需要修改controller方法，在要校验的pojo前边加上@Validated，<br><img src="https://raw.githubusercontent.com/tokerr/markdownImage/master/hibernate-validation%E6%A0%A1%E9%AA%8C/Image%207.png" alt=""></p><p>错误信息输出：<br><img src="https://raw.githubusercontent.com/tokerr/markdownImage/master/hibernate-validation%E6%A0%A1%E9%AA%8C/Image%208.png" alt=""></p><h4 id="1-6-在页面上展示错误"><a href="#1-6-在页面上展示错误" class="headerlink" title="1.6    在页面上展示错误"></a>1.6    在页面上展示错误</h4><p><img src="https://raw.githubusercontent.com/tokerr/markdownImage/master/hibernate-validation%E6%A0%A1%E9%AA%8C/Image%209.png" alt=""></p><h4 id="1-7-分组校验"><a href="#1-7-分组校验" class="headerlink" title="1.7    分组校验"></a>1.7    分组校验</h4><p>需求：<br>针对不同的controller方法通过分组校验达到个性化校验的目的，修改商品修改功能，只校验生产日期不能为空。</p><h5 id="第一步：创建分组接口"><a href="#第一步：创建分组接口" class="headerlink" title="第一步：创建分组接口"></a>第一步：创建分组接口</h5><p><img src="https://raw.githubusercontent.com/tokerr/markdownImage/master/hibernate-validation%E6%A0%A1%E9%AA%8C/Image%2010.png" alt=""></p><h5 id="第二步：定义校验规则属于哪个分组"><a href="#第二步：定义校验规则属于哪个分组" class="headerlink" title="第二步：定义校验规则属于哪个分组"></a>第二步：定义校验规则属于哪个分组</h5><p><img src="https://raw.githubusercontent.com/tokerr/markdownImage/master/hibernate-validation%E6%A0%A1%E9%AA%8C/Image%2011.png" alt=""></p><h5 id="第三步：在controller方法定义使用校验的分组"><a href="#第三步：在controller方法定义使用校验的分组" class="headerlink" title="第三步：在controller方法定义使用校验的分组"></a>第三步：在controller方法定义使用校验的分组</h5><p><img src="https://raw.githubusercontent.com/tokerr/markdownImage/master/hibernate-validation%E6%A0%A1%E9%AA%8C/Image%2012.png" alt=""> </p><h5 id="1-8-hibernate-validator的配置以及使用"><a href="#1-8-hibernate-validator的配置以及使用" class="headerlink" title="1.8    hibernate-validator的配置以及使用"></a>1.8    hibernate-validator的配置以及使用</h5><p><img src="https://raw.githubusercontent.com/tokerr/markdownImage/master/hibernate-validation%E6%A0%A1%E9%AA%8C/Image%2022.JPG" alt=""><br>此处只列出Hibernate Validator提供的大部分验证约束注解，请参考hibernate validator官方文档了解其他验证约束注解和进行自定义的验证约束注解定义。</p><h3 id="springmvc参数自动转换"><a href="#springmvc参数自动转换" class="headerlink" title="springmvc参数自动转换:"></a>springmvc参数自动转换:</h3><p>1.String to Date<br>2.String to Integer or int<br>3.String to Byte or int<br>4.String to Long or loong</p><pre><code>Failed to convert property value of type &apos;java.lang.String&apos; to required type &apos;java.lang.Byte&apos; for property &apos;duration&apos;; nested exception is org.springframework.core.convert.ConversionFailedException: Unable to convert value &quot;128&quot; from type &apos;java.lang.String&apos; to type &apos;java.lang.Byte&apos;; nested exception is java.lang.NumberFormatException: Value out of range. Value:&quot;128&quot; Radix:10Failed to convert property value of type &apos;java.lang.String&apos; to required type &apos;java.util.Date&apos; for property &apos;starttime&apos;; nested exception is org.springframework.core.convert.ConversionFailedException: Unable to convert value &quot;2017-01-23 16:25:45&quot; from type &apos;java.lang.String&apos; to type &apos;java.util.Date&apos;; nested exception is java.lang.IllegalStateException: JodaTime library not available - @DateTimeFormat not supported</code></pre><p><img src="https://raw.githubusercontent.com/tokerr/markdownImage/master/hibernate-validation%E6%A0%A1%E9%AA%8C/Image%2013.png" alt=""></p><p><img src="https://raw.githubusercontent.com/tokerr/markdownImage/master/hibernate-validation%E6%A0%A1%E9%AA%8C/Image%2014.png" alt=""></p><pre><code>http://127.0.0.1:8888/mokao-back/empfollowups/addEmpfollowups?empId=12988&amp;starttime=2015-06-04%2009:06:29&amp;duration=128&amp;salesid=325</code></pre><h3 id="Validator校验器使用正常"><a href="#Validator校验器使用正常" class="headerlink" title="Validator校验器使用正常"></a>Validator校验器使用正常</h3><pre><code>[    {        &quot;arguments&quot;: [            {                &quot;code&quot;: &quot;duration&quot;,                &quot;codes&quot;: [                    &quot;empfollowups.duration&quot;,                    &quot;duration&quot;                ],                &quot;defaultMessage&quot;: &quot;duration&quot;            }        ],        &quot;bindingFailure&quot;: true,        &quot;code&quot;: &quot;typeMismatch&quot;,        &quot;codes&quot;: [            &quot;typeMismatch.empfollowups.duration&quot;,            &quot;typeMismatch.duration&quot;,            &quot;typeMismatch.java.lang.Byte&quot;,            &quot;typeMismatch&quot;        ],        &quot;defaultMessage&quot;: &quot;Failed to convert property value of type &apos;java.lang.String&apos; to required type &apos;java.lang.Byte&apos; for property &apos;duration&apos;; nested exception is org.springframework.core.convert.ConversionFailedException: Unable to convert value &quot;128&quot; from type &apos;java.lang.String&apos; to type &apos;java.lang.Byte&apos;; nested exception is java.lang.NumberFormatException: Value out of range. Value:&quot;128&quot; Radix:10&quot;,        &quot;field&quot;: &quot;duration&quot;,        &quot;objectName&quot;: &quot;empfollowups&quot;,        &quot;rejectedValue&quot;: &quot;128&quot;    },    {        &quot;arguments&quot;: [            {                &quot;code&quot;: &quot;starttime&quot;,                &quot;codes&quot;: [                    &quot;empfollowups.starttime&quot;,                    &quot;starttime&quot;                ],                &quot;defaultMessage&quot;: &quot;starttime&quot;            }        ],        &quot;bindingFailure&quot;: true,        &quot;code&quot;: &quot;typeMismatch&quot;,        &quot;codes&quot;: [            &quot;typeMismatch.empfollowups.starttime&quot;,            &quot;typeMismatch.starttime&quot;,            &quot;typeMismatch.java.util.Date&quot;,            &quot;typeMismatch&quot;        ],        &quot;defaultMessage&quot;: &quot;Failed to convert property value of type &apos;java.lang.String&apos; to required type &apos;java.util.Date&apos; for property &apos;starttime&apos;; nested exception is org.springframework.core.convert.ConversionFailedException: Unable to convert value &quot;2015-06-04 09:06:29&quot; from type &apos;java.lang.String&apos; to type &apos;java.util.Date&apos;; nested exception is java.lang.IllegalStateException: JodaTime library not available - @DateTimeFormat not supported&quot;,        &quot;field&quot;: &quot;starttime&quot;,        &quot;objectName&quot;: &quot;empfollowups&quot;,        &quot;rejectedValue&quot;: &quot;2015-06-04 09:06:29&quot;    },    {        &quot;arguments&quot;: [            {                &quot;code&quot;: &quot;goal&quot;,                &quot;codes&quot;: [                    &quot;empfollowups.goal&quot;,                    &quot;goal&quot;                ],                &quot;defaultMessage&quot;: &quot;goal&quot;            }        ],        &quot;bindingFailure&quot;: false,        &quot;code&quot;: &quot;NotNull&quot;,        &quot;codes&quot;: [            &quot;NotNull.empfollowups.goal&quot;,            &quot;NotNull.goal&quot;,            &quot;NotNull.java.lang.String&quot;,            &quot;NotNull&quot;        ],        &quot;defaultMessage&quot;: &quot;回访目的不能为空!&quot;,        &quot;field&quot;: &quot;goal&quot;,        &quot;objectName&quot;: &quot;empfollowups&quot;    },    {        &quot;arguments&quot;: [            {                &quot;code&quot;: &quot;salesid&quot;,                &quot;codes&quot;: [                    &quot;empfollowups.salesid&quot;,                    &quot;salesid&quot;                ],                &quot;defaultMessage&quot;: &quot;salesid&quot;            },            127,            0        ],        &quot;bindingFailure&quot;: false,        &quot;code&quot;: &quot;Range&quot;,        &quot;codes&quot;: [            &quot;Range.empfollowups.salesid&quot;,            &quot;Range.salesid&quot;,            &quot;Range.java.lang.Integer&quot;,            &quot;Range&quot;        ],        &quot;defaultMessage&quot;: &quot;回访时间范围请保持在0-127分钟之内!&quot;,        &quot;field&quot;: &quot;salesid&quot;,        &quot;objectName&quot;: &quot;empfollowups&quot;,        &quot;rejectedValue&quot;: 325    }]</code></pre><p>OK【对于以上 String to Byte 类型错误的原因是：传过去的参数超出-127~127的范围，因此出现数字格式化异常，若是绑定的参数在正常范围内即-127~127之内则能正常绑定】<br>NO【已经解决，@DateTimeFormat not support  对于日期格式的字符串配置的springmvc的转换去没有转换成功<br>         异常原因：缺少jar包<br>          导入如下jar包即可使用注解的方式将pojo中string类型字符串转换成日期对象:joda-time库<br>】<br><img src="https://raw.githubusercontent.com/tokerr/markdownImage/master/hibernate-validation%E6%A0%A1%E9%AA%8C/Image%2015.png" alt=""></p><h3 id="二、以下是springmvc中validator的配置："><a href="#二、以下是springmvc中validator的配置：" class="headerlink" title="二、以下是springmvc中validator的配置："></a>二、以下是springmvc中validator的配置：</h3><p> 2.1先引入相关jar包:已附录在首行，3个相关jar包，若是需要使用注解对pojo中的Date类型进行转换，需要将joda-time也一并引入</p><p> 2.2 配置：<br><img src="https://raw.githubusercontent.com/tokerr/markdownImage/master/hibernate-validation%E6%A0%A1%E9%AA%8C/Image%2016.png" alt=""><br><img src="https://raw.githubusercontent.com/tokerr/markdownImage/master/hibernate-validation%E6%A0%A1%E9%AA%8C/Image%2017.png" alt=""><br><img src="https://raw.githubusercontent.com/tokerr/markdownImage/master/hibernate-validation%E6%A0%A1%E9%AA%8C/Image%2018.png" alt=""></p><p>控制器<br><img src="https://raw.githubusercontent.com/tokerr/markdownImage/master/hibernate-validation%E6%A0%A1%E9%AA%8C/Image%2019.png" alt=""></p><p> 2.3相关文件：源码文件，这里就不帖出来了</p><p> 2.4 pojo属性类型转换除了@DateTimeFormat 注解用于转换日期之外，还有可用于数字类型的属性转换的注解:@NumberFormat<br>@DateTimeFormat(pattern=”yyyy-MM-dd”) 可将形如1980-0-01的字符串转换到Date类<br>@NumberFormat(pattern=”#,###.##”) 可将形如4,500.00的字符串转换成long类型</p><p>2.5 List<objecterror> allErrors = bindingResult.getAllErrors(); allErrors 实例展示(这里转换成了json字符串)</objecterror></p><pre><code>http://127.0.0.1:8888/mokao-back/empfollowups/addEmpfollowups?empId=12988&amp;starttime=2015-06-04%2009:06:29&amp;duration=118&amp;salesid=325</code></pre><p><img src="https://raw.githubusercontent.com/tokerr/markdownImage/master/hibernate-validation%E6%A0%A1%E9%AA%8C/Image%2020.png" alt=""></p><pre><code>[    {        &quot;arguments&quot;: [            {                &quot;code&quot;: &quot;salesid&quot;,                &quot;codes&quot;: [                    &quot;empfollowups.salesid&quot;,                    &quot;salesid&quot;                ],                &quot;defaultMessage&quot;: &quot;salesid&quot;            },            127,            0        ],        &quot;bindingFailure&quot;: false,        &quot;code&quot;: &quot;Range&quot;,        &quot;codes&quot;: [            &quot;Range.empfollowups.salesid&quot;,            &quot;Range.salesid&quot;,            &quot;Range.java.lang.Integer&quot;,            &quot;Range&quot;        ],        &quot;defaultMessage&quot;: &quot;销售的id值请保持在0~127范围之内!&quot;,        &quot;field&quot;: &quot;salesid&quot;,        &quot;objectName&quot;: &quot;empfollowups&quot;,        &quot;rejectedValue&quot;: 325    },    {        &quot;arguments&quot;: [            {                &quot;code&quot;: &quot;goal&quot;,                &quot;codes&quot;: [                    &quot;empfollowups.goal&quot;,                    &quot;goal&quot;                ],                &quot;defaultMessage&quot;: &quot;goal&quot;            }        ],        &quot;bindingFailure&quot;: false,        &quot;code&quot;: &quot;NotNull&quot;,        &quot;codes&quot;: [            &quot;NotNull.empfollowups.goal&quot;,            &quot;NotNull.goal&quot;,            &quot;NotNull.java.lang.String&quot;,            &quot;NotNull&quot;        ],        &quot;defaultMessage&quot;: &quot;回访目的不能为空!&quot;,        &quot;field&quot;: &quot;goal&quot;,        &quot;objectName&quot;: &quot;empfollowups&quot;    }]</code></pre><p><img src="https://raw.githubusercontent.com/tokerr/markdownImage/master/hibernate-validation%E6%A0%A1%E9%AA%8C/Image%2021.png" alt=""></p><pre><code>org.codehaus.jackson.map.JsonMappingException: No serializer found for class org.springframework.validation.DefaultMessageCodesResolver and no properties discovered to create BeanSerializer (to avoid exception, disable SerializationConfig.Feature.FAIL_ON_EMPTY_BEANS) ) (through reference chain: org.springframework.validation.BeanPropertyBindingResult[&quot;messageCodesResolver&quot;])     at org.codehaus.jackson.map.ser.impl.UnknownSerializer.failForEmpty(UnknownSerializer.java:52)     at org.codehaus.jackson.map.ser.impl.UnknownSerializer.serialize(UnknownSerializer.java:25)     at org.codehaus.jackson.map.ser.BeanPropertyWriter.serializeAsField(BeanPropertyWriter.java:446)     at org.codehaus.jackson.map.ser.std.BeanSerializerBase.serializeFields(BeanSerializerBase.java:150)     at org.codehaus.jackson.map.ser.BeanSerializer.serialize(BeanSerializer.java:112)     at org.codehaus.jackson.map.ser.StdSerializerProvider._serializeValue(StdSerializerProvider.java:610)     at org.codehaus.jackson.map.ser.StdSerializerProvider.serializeValue(StdSerializerProvider.java:256)     at org.codehaus.jackson.map.ObjectMapper._configAndWriteValue(ObjectMapper.java:2575)     at org.codehaus.jackson.map.ObjectMapper.writeValueAsString(ObjectMapper.java:2097)     at com.skf.mokao.controller.empfollowups.EmpfollowupsController.addEmpfollowups(EmpfollowupsController.java:125)     at com.skf.mokao.controller.empfollowups.EmpfollowupsController$$FastClassByCGLIB$$2006e11c.invoke(&lt;generated&gt;)     at net.sf.cglib.proxy.MethodProxy.invoke(MethodProxy.java:191)     at org.springframework.aop.framework.Cglib2AopProxy$CglibMethodInvocation.invokeJoinpoint(Cglib2AopProxy.java:688)     at org.springframework.aop.framework.ReflectiveMethodInvocation.proceed(ReflectiveMethodInvocation.java:150)     at org.springframework.aop.aspectj.AspectJAfterAdvice.invoke(AspectJAfterAdvice.java:42)     at org.springframework.aop.framework.ReflectiveMethodInvocation.proceed(ReflectiveMethodInvocation.java:172)     at org.springframework.aop.aspectj.MethodInvocationProceedingJoinPoint.proceed(MethodInvocationProceedingJoinPoint.java:80)     at com.skf.mokao.aspect.Aspect5_LoginCheck.around(Aspect5_LoginCheck.java:146)     at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)     at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:57)     at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)     at java.lang.reflect.Method.invoke(Method.java:606)     at org.springframework.aop.aspectj.AbstractAspectJAdvice.invokeAdviceMethodWithGivenArgs(AbstractAspectJAdvice.java:621)     at org.springframework.aop.aspectj.AbstractAspectJAdvice.invokeAdviceMethod(AbstractAspectJAdvice.java:610)     at org.springframework.aop.aspectj.AspectJAroundAdvice.invoke(AspectJAroundAdvice.java:65)     at org.springframework.aop.framework.ReflectiveMethodInvocation.proceed(ReflectiveMethodInvocation.java:172)     at org.springframework.aop.interceptor.ExposeInvocationInterceptor.invoke(ExposeInvocationInterceptor.java:89)     at org.springframework.aop.framework.ReflectiveMethodInvocation.proceed(ReflectiveMethodInvocation.java:172)     at org.springframework.aop.framework.Cglib2AopProxy$DynamicAdvisedInterceptor.intercept(Cglib2AopProxy.java:621)     at com.skf.mokao.controller.empfollowups.EmpfollowupsController$$EnhancerByCGLIB$$8b5e69da.addEmpfollowups(&lt;generated&gt;)     at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)     at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:57)     at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)     at java.lang.reflect.Method.invoke(Method.java:606)     at org.springframework.web.bind.annotation.support.HandlerMethodInvoker.invokeHandlerMethod(HandlerMethodInvoker.java:176)     at org.springframework.web.servlet.mvc.annotation.AnnotationMethodHandlerAdapter.invokeHandlerMethod(AnnotationMethodHandlerAdapter.java:426)     at org.springframework.web.servlet.mvc.annotation.AnnotationMethodHandlerAdapter.handle(AnnotationMethodHandlerAdapter.java:414)     at org.springframework.web.servlet.DispatcherServlet.doDispatch(DispatcherServlet.java:790)     at org.springframework.web.servlet.DispatcherServlet.doService(DispatcherServlet.java:719)     at org.springframework.web.servlet.FrameworkServlet.processRequest(FrameworkServlet.java:644)     at org.springframework.web.servlet.FrameworkServlet.doGet(FrameworkServlet.java:549)     at javax.servlet.http.HttpServlet.service(HttpServlet.java:624)     at javax.servlet.http.HttpServlet.service(HttpServlet.java:731)     at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:303)     at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:208)     at org.apache.tomcat.websocket.server.WsFilter.doFilter(WsFilter.java:52)     at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:241)     at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:208)     at com.skf.mokao.filter.UserLoginFilter.doFilter(UserLoginFilter.java:63)     at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:241)     at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:208)     at org.apache.shiro.web.servlet.AbstractShiroFilter.executeChain(AbstractShiroFilter.java:449)     at org.apache.shiro.web.servlet.AbstractShiroFilter$1.call(AbstractShiroFilter.java:365)     at org.apache.shiro.subject.support.SubjectCallable.doCall(SubjectCallable.java:90)     at org.apache.shiro.subject.support.SubjectCallable.call(SubjectCallable.java:83)     at org.apache.shiro.subject.support.DelegatingSubject.execute(DelegatingSubject.java:380)     at org.apache.shiro.web.servlet.AbstractShiroFilter.doFilterInternal(AbstractShiroFilter.java:362)     at org.apache.shiro.web.servlet.OncePerRequestFilter.doFilter(OncePerRequestFilter.java:125)     at org.springframework.web.filter.DelegatingFilterProxy.invokeDelegate(DelegatingFilterProxy.java:237)     at org.springframework.web.filter.DelegatingFilterProxy.doFilter(DelegatingFilterProxy.java:167)     at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:241)     at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:208)     at org.springframework.web.filter.CharacterEncodingFilter.doFilterInternal(CharacterEncodingFilter.java:88)     at org.springframework.web.filter.OncePerRequestFilter.doFilter(OncePerRequestFilter.java:76)     at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:241)     at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:208)     at com.skf.mokao.filter.RequestParametersFilter.doFilter(RequestParametersFilter.java:138)     at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:241)     at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:208)     at org.apache.catalina.core.StandardWrapperValve.invoke(StandardWrapperValve.java:218)     at org.apache.catalina.core.StandardContextValve.invoke(StandardContextValve.java:122)     at org.apache.catalina.authenticator.AuthenticatorBase.invoke(AuthenticatorBase.java:505)     at org.apache.catalina.core.StandardHostValve.invoke(StandardHostValve.java:169)     at org.apache.catalina.valves.ErrorReportValve.invoke(ErrorReportValve.java:103)     at org.apache.catalina.valves.AccessLogValve.invoke(AccessLogValve.java:956)     at org.apache.catalina.core.StandardEngineValve.invoke(StandardEngineValve.java:116)     at org.apache.catalina.connector.CoyoteAdapter.service(CoyoteAdapter.java:442)     at org.apache.coyote.http11.AbstractHttp11Processor.process(AbstractHttp11Processor.java:1083)     at org.apache.coyote.AbstractProtocol$AbstractConnectionHandler.process(AbstractProtocol.java:640)     at org.apache.tomcat.util.net.AprEndpoint$SocketProcessor.doRun(AprEndpoint.java:2517)     at org.apache.tomcat.util.net.AprEndpoint$SocketProcessor.run(AprEndpoint.java:2506)     at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1145)     at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:615)     at org.apache.tomcat.util.threads.TaskThread$WrappingRunnable.run(TaskThread.java:61)     at java.lang.Thread.run(Thread.java:745)</code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> validation </tag>
            
            <tag> spring </tag>
            
            <tag> springmvc </tag>
            
            <tag> hibernate-validation </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>在不同环境下使用Gson出现的Date格式化问题</title>
      <link href="/2017/04/27/%E5%9C%A8%E4%B8%8D%E5%90%8C%E7%8E%AF%E5%A2%83%E4%B8%8B%E4%BD%BF%E7%94%A8Gson%E5%87%BA%E7%8E%B0%E7%9A%84Date%E6%A0%BC%E5%BC%8F%E5%8C%96%E9%97%AE%E9%A2%98/"/>
      <url>/2017/04/27/%E5%9C%A8%E4%B8%8D%E5%90%8C%E7%8E%AF%E5%A2%83%E4%B8%8B%E4%BD%BF%E7%94%A8Gson%E5%87%BA%E7%8E%B0%E7%9A%84Date%E6%A0%BC%E5%BC%8F%E5%8C%96%E9%97%AE%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<p>在Java中处理JSON格式的数据时，Google Gson是个不错的选择，用起来挺方便的，也有一定灵活性。我现在工作中在参与的两个项目里都有用它。不过它在处理Date格式时有个小陷阱，在不同环境中部署时可能会遇到问题。 </p><p>Gson默认处理Date对象的序列化/反序列化是通过一个SimpleDateFormat对象来实现的，通过下面的代码去获取实例：<br>DateFormat.getDateTimeInstance()</p><p>在不同的locale环境中，这样获取到的SimpleDateFormat的模式字符串会不一样。<br>例如说，在我的开发机是Windows XP SP3，zh_CN.GBK，模式字符串是：<br>“yyyy-M-d H:mm:ss”<br><a id="more"></a><br>而在我们的一台测试服务器上，RHEL 5.4，en_US.UTF-8，模式字符串则是：<br>“MMM d, yyyy h:mm:ss a”</p><p>这就使得同样的Date对象通过Gson来序列化为JSON后内容不同。例如说要序列化的日期是2010-08-19 16:13:57，那么在我的开发机上得到的是：<br>“2010-8-19 16:13:57”</p><p>而在那台测试服务器上则是：<br>“Aug 19, 2010 4:13:57 PM”</p><p>这就……郁闷了。在一边序列化的内容在另一边会反序列化失败。 </p><p>为了避免使用Gson时遇到locale影响Date格式的问题，使用GsonBuilder来创建Gson对象，在创建过程中调用GsonBuilder.setDateFormat(String)指定一个固定的格式即可。例如：<br>Gson gson = new GsonBuilder()<br>  .setDateFormat(“yyyy-MM-dd HH:mm:ss”)<br>  .create();</p><p><a href="http://rednaxelafx.iteye.com/blog/788306" target="_blank" rel="external">原文链接</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> google </tag>
            
            <tag> json </tag>
            
            <tag> gson </tag>
            
            <tag> linux </tag>
            
            <tag> windows </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>sql语句使用临时数据，模拟构建一张临时表(用于一次性查询的)</title>
      <link href="/2017/04/26/sql%E8%AF%AD%E5%8F%A5%E4%BD%BF%E7%94%A8%E4%B8%B4%E6%97%B6%E6%95%B0%E6%8D%AE%EF%BC%8C%E6%A8%A1%E6%8B%9F%E6%9E%84%E5%BB%BA%E4%B8%80%E5%BC%A0%E4%B8%B4%E6%97%B6%E8%A1%A8-%E7%94%A8%E4%BA%8E%E4%B8%80%E6%AC%A1%E6%80%A7%E6%9F%A5%E8%AF%A2%E7%9A%84/"/>
      <url>/2017/04/26/sql%E8%AF%AD%E5%8F%A5%E4%BD%BF%E7%94%A8%E4%B8%B4%E6%97%B6%E6%95%B0%E6%8D%AE%EF%BC%8C%E6%A8%A1%E6%8B%9F%E6%9E%84%E5%BB%BA%E4%B8%80%E5%BC%A0%E4%B8%B4%E6%97%B6%E8%A1%A8-%E7%94%A8%E4%BA%8E%E4%B8%80%E6%AC%A1%E6%80%A7%E6%9F%A5%E8%AF%A2%E7%9A%84/</url>
      
        <content type="html"><![CDATA[<h3 id="一、问题描述："><a href="#一、问题描述：" class="headerlink" title="一、问题描述："></a>一、问题描述：</h3><p>项目使用到了sendcloud的邮件服务，邮件的发送接口前期已经写好了，前几天突然需要看到取消接收我们公司发出去的邮件列表，由于又是后台的功能，所以交到了我们的手上，逻辑也简单，就是第一次去调用服务商的接口，至于如何调用，方法也不少，这里也不赘述，进入主题：</p><p>因为sendcloud服务商烦我返回的数据，除了一个邮箱的列表之外，没有必要的邮箱对应公司的名称(产品这边提的需求)，这点不难理解，详细的数据都在我们的数据库里面，因此在调用sendcloud的接口获取到邮箱列表之后还需要到我们的数据库中查询出对应的公司名称。</p><p>于是我就思考，每个邮箱单独去做一次查询，使用程序填装的方式，将企业名称一一对应封装，但是如果邮箱列表很多的情况下，就会影响数据库的性能，这是很不可取的，因此想着能不能通过sql的连接查询方式，把数据一次性的查询出来，只需要访问一次数据库即可：<br><strong>这样就需要将邮件列表在sql查询中组装成一张临时的表，然后再使用连接的方式查询企业的表从而获取到企业的详细信息</strong>，这样即使没有查到对应的企业，但是有限依然能正常显示。<br><a id="more"></a></p><h3 id="二、基本的操作"><a href="#二、基本的操作" class="headerlink" title="二、基本的操作"></a>二、基本的操作</h3><p>直接上图，简洁明了，想我不愿意看那么长描述性问题的人，问题写了那么多，觉得有点废话。</p><p><img src="http://i.imgur.com/OJ5Qj5r.png" alt=""></p><pre><code>select (&apos;111&apos;) AS num1,(5555) AS num2UNION ALLselect (&apos;111&apos;) AS num1,(null) AS num2</code></pre><p>注意：上面使用到了union all的合并查询，剩下的自己去领悟</p><h3 id="三、实际的应用：结合mybatis"><a href="#三、实际的应用：结合mybatis" class="headerlink" title="三、实际的应用：结合mybatis"></a>三、实际的应用：结合mybatis</h3><h4 id="3-1sql语句的编写"><a href="#3-1sql语句的编写" class="headerlink" title="3.1sql语句的编写"></a>3.1sql语句的编写</h4><p><img src="http://i.imgur.com/dGqmyYg.png" alt=""></p><p>sql语句：表结构就不贴出来了</p><pre><code>SELECT    temp.email,    temp.num2,    emp.id,    emp. NAMEFROM    (        SELECT            (&apos;2955*****@qq.com&apos;) AS email,(5555) AS num2        UNION ALL        SELECT            (&apos;hr@******.com&apos;) AS email,(5555) AS num2        UNION ALL        SELECT            (&apos;advertiser@****.com&apos;) AS email,(NULL) AS num2        UNION ALL        SELECT            (&apos;advertis@*****.com&apos;) AS email,(5555) AS num2    ) AS tempLEFT JOIN employers AS emp ON temp.email = emp.emailWHERE    emp.flag != &apos;D&apos;OR emp.flag IS NULL</code></pre><h4 id="3-2mapper-xml和dao接口"><a href="#3-2mapper-xml和dao接口" class="headerlink" title="3.2mapper.xml和dao接口"></a>3.2mapper.xml和dao接口</h4><p>3.2.1 dao接口：</p><p><img src="http://i.imgur.com/atdsOIp.png" alt=""></p><pre><code>public List&lt;Employers&gt; queryUnsubscribeByPage_(@Param(&quot;emails&quot;) List&lt;SCEmailUnsubscribe.Data&gt; emails,@Param(&quot;condition&quot;)SCEmailUnsubscribe.Data condition,@Param(&quot;startNum&quot;)Integer startNum,@Param(&quot;pageSize&quot;)Integer pageSize);</code></pre><p>3.2.2 mapper.xml</p><p><img src="http://i.imgur.com/yFAWc4d.png" alt=""></p><pre><code>&lt;sql id=&quot;Condition_And_Clause_&quot;&gt;      &lt;if test=&quot;condition!=null&quot;&gt;          &lt;if test=&quot;condition.empname!=null&quot;&gt;        AND `Name` LIKE #{condition.empname,jdbcType=VARCHAR}        &lt;/if&gt;          &lt;if test=&quot;condition.email!=null&quot;&gt;        AND `Email` LIKE #{condition.email,jdbcType=VARCHAR}        &lt;/if&gt;      &lt;/if&gt;  &lt;/sql&gt;   &lt;select id=&quot;queryUnsubscribeByPage_&quot;  resultType=&quot;com.skf.mokao.pojo.Employers&quot;&gt;       SELECT        temp.email AS email,        STR_TO_DATE(temp.unsubscribeTime,&apos;%Y-%m-%d %H:%i:%s&apos;) AS unsubscribeTime,        emp.id AS id,        emp.name AS name    FROM        (        &lt;if test=&quot;emails!=null&quot;&gt;            &lt;foreach collection=&quot;emails&quot; open=&quot;SELECT &quot; close=&quot;&quot; item=&quot;item&quot; separator=&quot; UNION ALL SELECT &quot;&gt;                (#{item.email}) AS email,(#{item.unsubscribeTime,jdbcType=TIMESTAMP}) AS unsubscribeTime            &lt;/foreach&gt;        &lt;/if&gt;        ) AS temp    LEFT JOIN employers AS emp ON temp.email = emp.email    WHERE        emp.flag != &apos;D&apos;    OR emp.flag IS NULL    &lt;include refid=&quot;Condition_And_Clause_&quot;/&gt;    ORDER BY temp.unsubscribeTime DESC    LIMIT #{startNum,jdbcType=INTEGER},#{pageSize,jdbcType=INTEGER}  &lt;/select&gt;  &lt;select id=&quot;queryUnsubscribeCount_&quot;  resultType=&quot;java.lang.Integer&quot;  &gt;          SELECT            COUNT(temp.email)        FROM            (            &lt;if test=&quot;emails!=null&quot;&gt;                &lt;foreach collection=&quot;emails&quot; open=&quot;SELECT &quot; close=&quot;&quot; item=&quot;item&quot; separator=&quot; UNION ALL SELECT &quot;&gt;                    (#{item.email}) AS email,(#{item.unsubscribeTime,jdbcType=TIMESTAMP}) AS unsubscribeTime                &lt;/foreach&gt;            &lt;/if&gt;            ) AS temp        LEFT JOIN employers AS emp ON temp.email = emp.email        WHERE            emp.flag != &apos;D&apos;        OR emp.flag IS NULL        &lt;include refid=&quot;Condition_And_Clause_&quot;/&gt;  &lt;/select&gt;</code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> mysql </tag>
            
            <tag> 临时表 </tag>
            
            <tag> mybatis </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>java.util.Date转java.sql.Date丢失时间问题</title>
      <link href="/2017/04/25/java-util-Date%E8%BD%ACjava-sql-Date%E4%B8%A2%E5%A4%B1%E6%97%B6%E9%97%B4%E9%97%AE%E9%A2%98/"/>
      <url>/2017/04/25/java-util-Date%E8%BD%ACjava-sql-Date%E4%B8%A2%E5%A4%B1%E6%97%B6%E9%97%B4%E9%97%AE%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<h3 id="一-引发我写这篇博客的原因（问题描述）："><a href="#一-引发我写这篇博客的原因（问题描述）：" class="headerlink" title="一.引发我写这篇博客的原因（问题描述）："></a>一.引发我写这篇博客的原因（问题描述）：</h3><p>由于项目使用的是springmvc+mybatis，前期的开发使用到了ibator这个dao层代码生成工具(ps:后来因为老板的原因，禁用了这个工具，但是以前的老代码还有在使用这个工具生成的代码)，其中提供的Example极大的方便开发是进行数据的各种查询的工作，但是使用过程出现了一些问题。<br>在对日期时间类型的字段进行筛选的时候不能精确到时分秒，原因是Example里面默认的是将util的Date 转成 sql的Date，以至丢失时间 查询不能精确到时分秒<br><img src="http://i.imgur.com/gvPzID2.png" alt=""><br><a id="more"></a></p><h3 id="二、问题原因以及解决方法："><a href="#二、问题原因以及解决方法：" class="headerlink" title="二、问题原因以及解决方法："></a>二、问题原因以及解决方法：</h3><pre><code>java.sql.Date 只存储日期数据不存储时间数据// 会丢失时间数据preparedStatement.setDate(1, new java.sql.Date(date.getTime()));//可以这样来处理preparedStatement.setTimestamp(1, new java.sql.Timestamp(new java.util.Date().getTime()));//想要得到完整的数据，包括日期和时间，可以这样java.util.Date d = resultSet.getTimestamp(1);//这样处理更合适一些，可以避免一些潜在Timestamp 问题java.util.Date d = new java.util.Date(resultSet.getTimestamp(1).getTime());</code></pre><p>这样的话：<br>往数据库存储的时候可以接收 java.util.Date类型 再用getTime()方法得到代表那个Date对象的long值，再以这个long值 构造一个Timestamp对象 存进数据库中。<br>从存数据库里取的时候，可以先得到Timestamp用他的getTime()方法得到long值，再以这个long值构造一个 java.util.Date对象，这样就可以对这个Date对象操作了。<br>例如 <code>new SimpleTimeFormat(&quot;yyyyy-MM-dd HH:mm:ss&quot;).format()</code>等等</p>]]></content>
      
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> 日期转换 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>简单易懂的更换hexo主题的教程</title>
      <link href="/2017/04/05/%E7%AE%80%E5%8D%95%E6%98%93%E6%87%82%E7%9A%84%E6%9B%B4%E6%8D%A2hexo%E4%B8%BB%E9%A2%98%E7%9A%84%E6%95%99%E7%A8%8B/"/>
      <url>/2017/04/05/%E7%AE%80%E5%8D%95%E6%98%93%E6%87%82%E7%9A%84%E6%9B%B4%E6%8D%A2hexo%E4%B8%BB%E9%A2%98%E7%9A%84%E6%95%99%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<h3 id="以Smackdown为例：http-blog-smackdown-gebilaowu-cn"><a href="#以Smackdown为例：http-blog-smackdown-gebilaowu-cn" class="headerlink" title="以Smackdown为例：http://blog.smackdown.gebilaowu.cn/"></a>以Smackdown为例：<a href="http://blog.smackdown.gebilaowu.cn/" target="_blank" rel="external">http://blog.smackdown.gebilaowu.cn/</a></h3><h2 id="一、预览的页面"><a href="#一、预览的页面" class="headerlink" title="一、预览的页面"></a>一、预览的页面</h2><p><img src="http://i.imgur.com/FnrgLQ1.png" alt=""></p><h2 id="二、到github中找到hexo主题的demo"><a href="#二、到github中找到hexo主题的demo" class="headerlink" title="二、到github中找到hexo主题的demo"></a>二、到github中找到hexo主题的demo</h2><p>一般的都会附带上github的demo地址，顺便附录上hexo官方的主题列表页面，大家可以在里面挑一款自己喜欢的(<a href="https://hexo.io/themes/)，这个官网的主题连接在_config.yml配置文件的themes属性配置的上面有。" target="_blank" rel="external">https://hexo.io/themes/)，这个官网的主题连接在_config.yml配置文件的themes属性配置的上面有。</a><br><a id="more"></a><br>图示的仓库地址：<a href="https://github.com/smackgg/hexo-theme-smackdown" target="_blank" rel="external">https://github.com/smackgg/hexo-theme-smackdown</a><br><img src="http://i.imgur.com/gq4YNxW.png" alt=""></p><h2 id="三、将主题的demo克隆到本地"><a href="#三、将主题的demo克隆到本地" class="headerlink" title="三、将主题的demo克隆到本地"></a>三、将主题的demo克隆到本地</h2><p>一定要确保克隆到自己bolg下面的themes下面(置于克隆到其他的文件夹我没有试过)<br><img src="http://i.imgur.com/8TZ1mtN.png" alt=""><br><img src="http://i.imgur.com/czznELY.png" alt=""><br><img src="http://i.imgur.com/vCnociV.png" alt=""><br><img src="http://i.imgur.com/NdUcEZK.png" alt=""></p><h2 id="四、更新操作："><a href="#四、更新操作：" class="headerlink" title="四、更新操作："></a>四、更新操作：</h2><p><img src="http://i.imgur.com/O0400DT.png" alt=""></p><h2 id="五、修改配置文件，打开-config-yml文件："><a href="#五、修改配置文件，打开-config-yml文件：" class="headerlink" title="五、修改配置文件，打开_config.yml文件："></a>五、修改配置文件，打开_config.yml文件：</h2><p><img src="http://i.imgur.com/b7el9jt.png" alt=""><br><img src="http://i.imgur.com/qItfGgV.png" alt=""></p><h2 id="六、启动本地预览效果："><a href="#六、启动本地预览效果：" class="headerlink" title="六、启动本地预览效果："></a>六、启动本地预览效果：</h2><p><img src="http://i.imgur.com/Qas8qMY.png" alt=""><br><img src="http://i.imgur.com/pC39DMr.png" alt=""></p><h2 id="七、部署到github服务器："><a href="#七、部署到github服务器：" class="headerlink" title="七、部署到github服务器："></a>七、部署到github服务器：</h2><p><img src="http://i.imgur.com/hUK1EZP.png" alt=""><br><img src="http://i.imgur.com/Bm91WSF.png" alt=""></p><h2 id="八、注意事项："><a href="#八、注意事项：" class="headerlink" title="八、注意事项："></a>八、注意事项：</h2><pre><code>8.1 由于windows的cmd一般是gbk方式编码，因此使用windows自带的cmd初始化blog之后，需要把_config.yml配置文件改成utf-8的编码格式，不然部署到服务器上浏览器打开会出现中文乱码。8.2 我搭建hexo博客，部署deploy的时候出现了error deployer not found:github 的错误，附上当前解决这个问题的连接：http://www.jianshu.com/p/5e0ca2b14815</code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> hexo 主题 更换 </tag>
            
        </tags>
      
    </entry>
    
  
  
</search>
